<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel Media Driver Document: CMRT_UMD::CmDevice Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Intel Media Driver Document<span id="projectnumber">&#160;24.2.6</span>
   </div>
   <div id="projectbrief">This document is for intel media driver which locate at https://github.com/intel/media-driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d8/df2/namespace_c_m_r_t___u_m_d.html">CMRT_UMD</a></li><li class="navelem"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html">CmDevice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../da/db3/class_c_m_r_t___u_m_d_1_1_cm_device-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CMRT_UMD::CmDevice Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> class @UMD for Linux.  
 <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/d64/cm__device_8h_source.html">cm_device.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aac7587352bbf001632edfc105ebf6b4a"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aac7587352bbf001632edfc105ebf6b4a">CreateBuffer</a> (uint32_t <a class="el" href="../../d8/df7/i915__drm__prelim_8h.html#a778fb2df652488eb52045d01ab72f0e1">size</a>, CmBuffer *&amp;surface)=0</td></tr>
<tr class="memdesc:aac7587352bbf001632edfc105ebf6b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmBuffer with specified size in bytes.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aac7587352bbf001632edfc105ebf6b4a">More...</a><br /></td></tr>
<tr class="separator:aac7587352bbf001632edfc105ebf6b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761b9add31d2fa628fc8d6d8868e3455"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a761b9add31d2fa628fc8d6d8868e3455">CreateBuffer</a> (<a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a> mosResource, CmBuffer *&amp;surface)=0</td></tr>
<tr class="memdesc:a761b9add31d2fa628fc8d6d8868e3455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmBuffer from an existing MOS Resource.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a761b9add31d2fa628fc8d6d8868e3455">More...</a><br /></td></tr>
<tr class="separator:a761b9add31d2fa628fc8d6d8868e3455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94604af1ac0cb113151d462d1d34fc45"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a94604af1ac0cb113151d462d1d34fc45">CreateSurface2D</a> (uint32_t <a class="el" href="../../d0/d85/i915__drm_8h.html#ade59943f8164f6f3c39ae96bd8cab86d">width</a>, uint32_t height, CM_SURFACE_FORMAT format, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;surface)=0</td></tr>
<tr class="memdesc:a94604af1ac0cb113151d462d1d34fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> with given width, height, and format.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a94604af1ac0cb113151d462d1d34fc45">More...</a><br /></td></tr>
<tr class="separator:a94604af1ac0cb113151d462d1d34fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896f952f65be2cd034d06385edaf279d"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a896f952f65be2cd034d06385edaf279d">CreateSurface2D</a> (<a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a> mosResource, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;surface)=0</td></tr>
<tr class="memdesc:a896f952f65be2cd034d06385edaf279d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> from an existing MOS Resource.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a896f952f65be2cd034d06385edaf279d">More...</a><br /></td></tr>
<tr class="separator:a896f952f65be2cd034d06385edaf279d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab176b4c08c43a2e7bd8c2056c6d8ccf9"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ab176b4c08c43a2e7bd8c2056c6d8ccf9">CreateSurface2D</a> (VASurfaceID vaSurface, VADriverContext *vaDriverCtx, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;surface)=0</td></tr>
<tr class="memdesc:ab176b4c08c43a2e7bd8c2056c6d8ccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> from an existing VA surface.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ab176b4c08c43a2e7bd8c2056c6d8ccf9">More...</a><br /></td></tr>
<tr class="separator:ab176b4c08c43a2e7bd8c2056c6d8ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026f83505fd025d89f1901bd1ce332eb"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a026f83505fd025d89f1901bd1ce332eb">CreateSurface3D</a> (uint32_t <a class="el" href="../../d0/d85/i915__drm_8h.html#ade59943f8164f6f3c39ae96bd8cab86d">width</a>, uint32_t height, uint32_t depth, CM_SURFACE_FORMAT format, CmSurface3D *&amp;surface)=0</td></tr>
<tr class="memdesc:a026f83505fd025d89f1901bd1ce332eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSurface3D with given width, height, depth and pixel format.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a026f83505fd025d89f1901bd1ce332eb">More...</a><br /></td></tr>
<tr class="separator:a026f83505fd025d89f1901bd1ce332eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1293d052930415e00d09f71352424cf"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae1293d052930415e00d09f71352424cf">DestroySurface</a> (CmBuffer *&amp;surface)=0</td></tr>
<tr class="memdesc:ae1293d052930415e00d09f71352424cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys CmBuffer object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae1293d052930415e00d09f71352424cf">More...</a><br /></td></tr>
<tr class="separator:ae1293d052930415e00d09f71352424cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a45c921f36bd99a799397bff9888fe6"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a7a45c921f36bd99a799397bff9888fe6">DestroySurface</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;surface)=0</td></tr>
<tr class="memdesc:a7a45c921f36bd99a799397bff9888fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> type surface.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a7a45c921f36bd99a799397bff9888fe6">More...</a><br /></td></tr>
<tr class="separator:a7a45c921f36bd99a799397bff9888fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e60536fd51c8f0a00388c1c2801f36"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a04e60536fd51c8f0a00388c1c2801f36">DestroySurface</a> (CmSurface3D *&amp;surface)=0</td></tr>
<tr class="memdesc:a04e60536fd51c8f0a00388c1c2801f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys CmSurface3D object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a04e60536fd51c8f0a00388c1c2801f36">More...</a><br /></td></tr>
<tr class="separator:a04e60536fd51c8f0a00388c1c2801f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad262813c3aa97907feab9b651e8b990b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad262813c3aa97907feab9b651e8b990b">CreateQueue</a> (CmQueue *&amp;queue)=0</td></tr>
<tr class="memdesc:ad262813c3aa97907feab9b651e8b990b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a task queue.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad262813c3aa97907feab9b651e8b990b">More...</a><br /></td></tr>
<tr class="separator:ad262813c3aa97907feab9b651e8b990b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56005b2f4fa8a79b067cedabbc545e0"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad56005b2f4fa8a79b067cedabbc545e0">LoadProgram</a> (void *commonIsaCode, const uint32_t <a class="el" href="../../d8/df7/i915__drm__prelim_8h.html#a778fb2df652488eb52045d01ab72f0e1">size</a>, CmProgram *&amp;program, const char *options=nullptr)=0</td></tr>
<tr class="memdesc:ad56005b2f4fa8a79b067cedabbc545e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmProgram object consisting of kernels loaded from the commonIsaCode code.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad56005b2f4fa8a79b067cedabbc545e0">More...</a><br /></td></tr>
<tr class="separator:ad56005b2f4fa8a79b067cedabbc545e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541fc359f7663966aca36c0f71a7c79"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a6541fc359f7663966aca36c0f71a7c79">CreateKernel</a> (CmProgram *program, const char *kernelName, CmKernel *&amp;kernel, const char *options=nullptr)=0</td></tr>
<tr class="memdesc:a6541fc359f7663966aca36c0f71a7c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmKernel object from the CmProgram object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a6541fc359f7663966aca36c0f71a7c79">More...</a><br /></td></tr>
<tr class="separator:a6541fc359f7663966aca36c0f71a7c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cd0035b7680aca2adb9461b9da70c8"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a09cd0035b7680aca2adb9461b9da70c8">CreateSampler</a> (const CM_SAMPLER_STATE &amp;sampleState, CmSampler *&amp;sampler)=0</td></tr>
<tr class="memdesc:a09cd0035b7680aca2adb9461b9da70c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSampler object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a09cd0035b7680aca2adb9461b9da70c8">More...</a><br /></td></tr>
<tr class="separator:a09cd0035b7680aca2adb9461b9da70c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb232f4f08dcc2d7f7d2fcf0a44ad9c"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aacb232f4f08dcc2d7f7d2fcf0a44ad9c">DestroyKernel</a> (CmKernel *&amp;kernel)=0</td></tr>
<tr class="memdesc:aacb232f4f08dcc2d7f7d2fcf0a44ad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a CmKernel.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aacb232f4f08dcc2d7f7d2fcf0a44ad9c">More...</a><br /></td></tr>
<tr class="separator:aacb232f4f08dcc2d7f7d2fcf0a44ad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac637343990cc52934e4922ef1a8ee11"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aac637343990cc52934e4922ef1a8ee11">DestroySampler</a> (CmSampler *&amp;sampler)=0</td></tr>
<tr class="memdesc:aac637343990cc52934e4922ef1a8ee11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a CmSampler.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aac637343990cc52934e4922ef1a8ee11">More...</a><br /></td></tr>
<tr class="separator:aac637343990cc52934e4922ef1a8ee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12298eea2601ad1cc0a8a9389fa7c5d7"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a12298eea2601ad1cc0a8a9389fa7c5d7">DestroyProgram</a> (CmProgram *&amp;program)=0</td></tr>
<tr class="memdesc:a12298eea2601ad1cc0a8a9389fa7c5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a CmProgram.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a12298eea2601ad1cc0a8a9389fa7c5d7">More...</a><br /></td></tr>
<tr class="separator:a12298eea2601ad1cc0a8a9389fa7c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e42a440e8ec99761e3f35b719f23d75"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a7e42a440e8ec99761e3f35b719f23d75">DestroyThreadSpace</a> (CmThreadSpace *&amp;threadSpace)=0</td></tr>
<tr class="memdesc:a7e42a440e8ec99761e3f35b719f23d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a CmThreadSpace instance.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a7e42a440e8ec99761e3f35b719f23d75">More...</a><br /></td></tr>
<tr class="separator:a7e42a440e8ec99761e3f35b719f23d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceea38761c0eadbd1bd6bf1966595f84"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aceea38761c0eadbd1bd6bf1966595f84">CreateTask</a> (CmTask *&amp;task)=0</td></tr>
<tr class="memdesc:aceea38761c0eadbd1bd6bf1966595f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmTask object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aceea38761c0eadbd1bd6bf1966595f84">More...</a><br /></td></tr>
<tr class="separator:aceea38761c0eadbd1bd6bf1966595f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b8b85dbe6213b6abf934cd6b267324"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a31b8b85dbe6213b6abf934cd6b267324">DestroyTask</a> (CmTask *&amp;task)=0</td></tr>
<tr class="memdesc:a31b8b85dbe6213b6abf934cd6b267324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CmTask object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a31b8b85dbe6213b6abf934cd6b267324">More...</a><br /></td></tr>
<tr class="separator:a31b8b85dbe6213b6abf934cd6b267324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5459c7ca2ff0a37951764c054838a45"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ab5459c7ca2ff0a37951764c054838a45">GetCaps</a> (CM_DEVICE_CAP_NAME capName, uint32_t &amp;capValueSize, void *capValue)=0</td></tr>
<tr class="memdesc:ab5459c7ca2ff0a37951764c054838a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to get HW capability.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ab5459c7ca2ff0a37951764c054838a45">More...</a><br /></td></tr>
<tr class="separator:ab5459c7ca2ff0a37951764c054838a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cdf2a6f165d7db73b9b686f2e57784"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a37cdf2a6f165d7db73b9b686f2e57784">CreateThreadSpace</a> (uint32_t <a class="el" href="../../d0/d85/i915__drm_8h.html#ade59943f8164f6f3c39ae96bd8cab86d">width</a>, uint32_t height, CmThreadSpace *&amp;threadSpace)=0</td></tr>
<tr class="memdesc:a37cdf2a6f165d7db73b9b686f2e57784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmThreadSpace object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a37cdf2a6f165d7db73b9b686f2e57784">More...</a><br /></td></tr>
<tr class="separator:a37cdf2a6f165d7db73b9b686f2e57784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82e7e9569684292a34def52a77abab1"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad82e7e9569684292a34def52a77abab1">CreateBufferUP</a> (uint32_t <a class="el" href="../../d8/df7/i915__drm__prelim_8h.html#a778fb2df652488eb52045d01ab72f0e1">size</a>, void *sysMem, CmBufferUP *&amp;surface)=0</td></tr>
<tr class="memdesc:ad82e7e9569684292a34def52a77abab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmBufferUP object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad82e7e9569684292a34def52a77abab1">More...</a><br /></td></tr>
<tr class="separator:ad82e7e9569684292a34def52a77abab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97b05a1bec364934aa6045d0d0db068"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ac97b05a1bec364934aa6045d0d0db068">DestroyBufferUP</a> (CmBufferUP *&amp;surface)=0</td></tr>
<tr class="memdesc:ac97b05a1bec364934aa6045d0d0db068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys CmBufferUP object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ac97b05a1bec364934aa6045d0d0db068">More...</a><br /></td></tr>
<tr class="separator:ac97b05a1bec364934aa6045d0d0db068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52bd18f6de5184dbe014e2bb62575a4"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ac52bd18f6de5184dbe014e2bb62575a4">ForceDestroyBufferUP</a> (CmBufferUP *&amp;surface)=0</td></tr>
<tr class="memdesc:ac52bd18f6de5184dbe014e2bb62575a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces the BufferUP object to be destroyed.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ac52bd18f6de5184dbe014e2bb62575a4">More...</a><br /></td></tr>
<tr class="separator:ac52bd18f6de5184dbe014e2bb62575a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbcddd96adb0e8f9f553b506a58ed2b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a8cbcddd96adb0e8f9f553b506a58ed2b">GetSurface2DInfo</a> (uint32_t <a class="el" href="../../d0/d85/i915__drm_8h.html#ade59943f8164f6f3c39ae96bd8cab86d">width</a>, uint32_t height, CM_SURFACE_FORMAT format, uint32_t &amp;pitch, uint32_t &amp;physicalSize)=0</td></tr>
<tr class="memdesc:a8cbcddd96adb0e8f9f553b506a58ed2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Surface2D allocation information by given width, height, and format.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a8cbcddd96adb0e8f9f553b506a58ed2b">More...</a><br /></td></tr>
<tr class="separator:a8cbcddd96adb0e8f9f553b506a58ed2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a3267c83ee9180ad71aaafcce61c8f"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a43a3267c83ee9180ad71aaafcce61c8f">CreateSurface2DUP</a> (uint32_t <a class="el" href="../../d0/d85/i915__drm_8h.html#ade59943f8164f6f3c39ae96bd8cab86d">width</a>, uint32_t height, CM_SURFACE_FORMAT format, void *sysMem, CmSurface2DUP *&amp;surface)=0</td></tr>
<tr class="memdesc:a43a3267c83ee9180ad71aaafcce61c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSurface2DUP object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a43a3267c83ee9180ad71aaafcce61c8f">More...</a><br /></td></tr>
<tr class="separator:a43a3267c83ee9180ad71aaafcce61c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba048383eae043cf72c4134ab8549f5"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a2ba048383eae043cf72c4134ab8549f5">DestroySurface2DUP</a> (CmSurface2DUP *&amp;surface)=0</td></tr>
<tr class="memdesc:a2ba048383eae043cf72c4134ab8549f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys CmSurface2DUP surface.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a2ba048383eae043cf72c4134ab8549f5">More...</a><br /></td></tr>
<tr class="separator:a2ba048383eae043cf72c4134ab8549f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6183a8afff1b703488b10a9cdb62ff29"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a6183a8afff1b703488b10a9cdb62ff29">CreateVmeSurfaceG7_5</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *currentSurface, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **forwardSurfaces, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **backwardSurfaces, const uint32_t forwardSurfaceCount, const uint32_t backwardSurfaceCount, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;vmeIndex)=0</td></tr>
<tr class="memdesc:a6183a8afff1b703488b10a9cdb62ff29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a VME surface for AVC messages in kernel.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a6183a8afff1b703488b10a9cdb62ff29">More...</a><br /></td></tr>
<tr class="separator:a6183a8afff1b703488b10a9cdb62ff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a03d756c9bd108c3fa393eae8c738e8"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a6a03d756c9bd108c3fa393eae8c738e8">DestroyVmeSurfaceG7_5</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;vmeIndex)=0</td></tr>
<tr class="memdesc:a6a03d756c9bd108c3fa393eae8c738e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a VME surface object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a6a03d756c9bd108c3fa393eae8c738e8">More...</a><br /></td></tr>
<tr class="separator:a6a03d756c9bd108c3fa393eae8c738e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b04b93e9fe28a7bf5f80fed4c2c84e"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a71b04b93e9fe28a7bf5f80fed4c2c84e">CreateSampler8x8</a> (const CM_SAMPLER_8X8_DESCR &amp;sampler8x8Descriptor, CmSampler8x8 *&amp;sampler8x8)=0</td></tr>
<tr class="memdesc:a71b04b93e9fe28a7bf5f80fed4c2c84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSampler8x8 object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a71b04b93e9fe28a7bf5f80fed4c2c84e">More...</a><br /></td></tr>
<tr class="separator:a71b04b93e9fe28a7bf5f80fed4c2c84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f6dd478dcfdad8c9abe5709d34e339"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ac1f6dd478dcfdad8c9abe5709d34e339">DestroySampler8x8</a> (CmSampler8x8 *&amp;sampler8x8State)=0</td></tr>
<tr class="memdesc:ac1f6dd478dcfdad8c9abe5709d34e339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a CmSampler8x8 object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ac1f6dd478dcfdad8c9abe5709d34e339">More...</a><br /></td></tr>
<tr class="separator:ac1f6dd478dcfdad8c9abe5709d34e339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a2947cacd5c119dce23399577cbc5e"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16a2947cacd5c119dce23399577cbc5e">CreateSampler8x8Surface</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *surface2d, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;sampler8x8SurfIndex, CM_SAMPLER8x8_SURFACE surfType, CM_SURFACE_ADDRESS_CONTROL_MODE mode)=0</td></tr>
<tr class="memdesc:a16a2947cacd5c119dce23399577cbc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSampler8x8 surface.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16a2947cacd5c119dce23399577cbc5e">More...</a><br /></td></tr>
<tr class="separator:a16a2947cacd5c119dce23399577cbc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8dbb1c5528ecc8e4f1885c9c8a69be"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aff8dbb1c5528ecc8e4f1885c9c8a69be">DestroySampler8x8Surface</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;sampler8x8SurfIndex)=0</td></tr>
<tr class="memdesc:aff8dbb1c5528ecc8e4f1885c9c8a69be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a CmSampler8x8 surface.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aff8dbb1c5528ecc8e4f1885c9c8a69be">More...</a><br /></td></tr>
<tr class="separator:aff8dbb1c5528ecc8e4f1885c9c8a69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fe60daf86914eedd6bf6e9a21a0d0b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae5fe60daf86914eedd6bf6e9a21a0d0b">CreateThreadGroupSpace</a> (uint32_t threadSpaceWidth, uint32_t threadSpaceHeight, uint32_t groupSpaceWidth, uint32_t groupSpaceHeight, CmThreadGroupSpace *&amp;threadGroupSpace)=0</td></tr>
<tr class="memdesc:ae5fe60daf86914eedd6bf6e9a21a0d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2-dimensional thread group space object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae5fe60daf86914eedd6bf6e9a21a0d0b">More...</a><br /></td></tr>
<tr class="separator:ae5fe60daf86914eedd6bf6e9a21a0d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162b4a497286e284ac6af8c8158c683d"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a162b4a497286e284ac6af8c8158c683d">DestroyThreadGroupSpace</a> (CmThreadGroupSpace *&amp;threadGroupSpace)=0</td></tr>
<tr class="memdesc:a162b4a497286e284ac6af8c8158c683d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the created thread group space object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a162b4a497286e284ac6af8c8158c683d">More...</a><br /></td></tr>
<tr class="separator:a162b4a497286e284ac6af8c8158c683d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d036e7ea22baed89307ed1e5f16c744"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a5d036e7ea22baed89307ed1e5f16c744">SetL3Config</a> (const L3ConfigRegisterValues *l3Config)=0</td></tr>
<tr class="memdesc:a5d036e7ea22baed89307ed1e5f16c744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the configuration for L3 cache.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a5d036e7ea22baed89307ed1e5f16c744">More...</a><br /></td></tr>
<tr class="separator:a5d036e7ea22baed89307ed1e5f16c744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9ef126243d4246a0a59e8879e13404"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a4c9ef126243d4246a0a59e8879e13404">SetSuggestedL3Config</a> (L3_SUGGEST_CONFIG l3SuggestConfig)=0</td></tr>
<tr class="memdesc:a4c9ef126243d4246a0a59e8879e13404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the suggested configuration for L3 cache.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a4c9ef126243d4246a0a59e8879e13404">More...</a><br /></td></tr>
<tr class="separator:a4c9ef126243d4246a0a59e8879e13404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5a716edbf90cb2faf4a59635aa7160"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a2d5a716edbf90cb2faf4a59635aa7160">SetCaps</a> (CM_DEVICE_CAP_NAME capName, size_t capValueSize, void *capValue)=0</td></tr>
<tr class="memdesc:a2d5a716edbf90cb2faf4a59635aa7160"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to set/limit hardware capabilities- number of threads that HW can run in parallel.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a2d5a716edbf90cb2faf4a59635aa7160">More...</a><br /></td></tr>
<tr class="separator:a2d5a716edbf90cb2faf4a59635aa7160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea37539e05e12eef94463f9fe3cb230"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a1ea37539e05e12eef94463f9fe3cb230">CreateSamplerSurface2D</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *surface2d, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;samplerSurfaceIndex)=0</td></tr>
<tr class="memdesc:a1ea37539e05e12eef94463f9fe3cb230"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a sampler surface index by a given <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a1ea37539e05e12eef94463f9fe3cb230">More...</a><br /></td></tr>
<tr class="separator:a1ea37539e05e12eef94463f9fe3cb230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16df972b7d4ea2715ae95a33703a9416"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16df972b7d4ea2715ae95a33703a9416">CreateSamplerSurface3D</a> (CmSurface3D *surface3d, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;samplerSurfaceIndex)=0</td></tr>
<tr class="memdesc:a16df972b7d4ea2715ae95a33703a9416"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a sampler surface index by a given CmSurface3D.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16df972b7d4ea2715ae95a33703a9416">More...</a><br /></td></tr>
<tr class="separator:a16df972b7d4ea2715ae95a33703a9416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179144894e0a224e857ba78b8623d5b5"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a179144894e0a224e857ba78b8623d5b5">DestroySamplerSurface</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;samplerSurfaceIndex)=0</td></tr>
<tr class="memdesc:a179144894e0a224e857ba78b8623d5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function destroys a sampler surface index created by <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a1ea37539e05e12eef94463f9fe3cb230" title="This function creates a sampler surface index by a given CmSurface2D.">CreateSamplerSurface2D()</a>, CreateSamplerSurface2DUP, or <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16df972b7d4ea2715ae95a33703a9416" title="This function creates a sampler surface index by a given CmSurface3D.">CreateSamplerSurface3D()</a>.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a179144894e0a224e857ba78b8623d5b5">More...</a><br /></td></tr>
<tr class="separator:a179144894e0a224e857ba78b8623d5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc52c3f35d597e83ae5345f094650e1c"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#afc52c3f35d597e83ae5345f094650e1c">InitPrintBuffer</a> (size_t <a class="el" href="../../d8/df7/i915__drm__prelim_8h.html#a778fb2df652488eb52045d01ab72f0e1">size</a>=CM_DEFAULT_PRINT_BUFFER_SIZE)=0</td></tr>
<tr class="memdesc:afc52c3f35d597e83ae5345f094650e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a buffer to store the message printed by printf() in kernel side.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#afc52c3f35d597e83ae5345f094650e1c">More...</a><br /></td></tr>
<tr class="separator:afc52c3f35d597e83ae5345f094650e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119687d90a19d1f7e9b18dfa5ae0cdc3"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a119687d90a19d1f7e9b18dfa5ae0cdc3">FlushPrintBuffer</a> ()=0</td></tr>
<tr class="memdesc:a119687d90a19d1f7e9b18dfa5ae0cdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the message on the standard display device that are dumped by kernel.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a119687d90a19d1f7e9b18dfa5ae0cdc3">More...</a><br /></td></tr>
<tr class="separator:a119687d90a19d1f7e9b18dfa5ae0cdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029356303e85c9d36f847d37b19ff768"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a029356303e85c9d36f847d37b19ff768">CreateVebox</a> (CmVebox *&amp;vebox)=0</td></tr>
<tr class="memdesc:a029356303e85c9d36f847d37b19ff768"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a VEBOX object for VEBOX operations (<a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol09-media_vebox.pdf">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol09-media_vebox.pdf</a>).  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a029356303e85c9d36f847d37b19ff768">More...</a><br /></td></tr>
<tr class="separator:a029356303e85c9d36f847d37b19ff768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc20c0af1a55bad977331986c73d1d56"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#abc20c0af1a55bad977331986c73d1d56">DestroyVebox</a> (CmVebox *&amp;vebox)=0</td></tr>
<tr class="memdesc:abc20c0af1a55bad977331986c73d1d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function destroys a VEBOX object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#abc20c0af1a55bad977331986c73d1d56">More...</a><br /></td></tr>
<tr class="separator:abc20c0af1a55bad977331986c73d1d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd99e0eaf3cff957fd05eaebe6eeefa3"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#abd99e0eaf3cff957fd05eaebe6eeefa3">CreateBufferSVM</a> (uint32_t <a class="el" href="../../d8/df7/i915__drm__prelim_8h.html#a778fb2df652488eb52045d01ab72f0e1">size</a>, void *&amp;sysMem, uint32_t accessFlag, CmBufferSVM *&amp;bufferSVM)=0</td></tr>
<tr class="memdesc:abd99e0eaf3cff957fd05eaebe6eeefa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It creates a CmBufferSVM of the specified size in bytes by using the SVM (shared virtual memory) system memory. (<a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol05-memory_views.pdf">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol05-memory_views.pdf</a>).  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#abd99e0eaf3cff957fd05eaebe6eeefa3">More...</a><br /></td></tr>
<tr class="separator:abd99e0eaf3cff957fd05eaebe6eeefa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc325909bbab691b330b7764e051bf6"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aebc325909bbab691b330b7764e051bf6">DestroyBufferSVM</a> (CmBufferSVM *&amp;bufferSVM)=0</td></tr>
<tr class="memdesc:aebc325909bbab691b330b7764e051bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys CmBufferSVM object and associated SVM memory.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aebc325909bbab691b330b7764e051bf6">More...</a><br /></td></tr>
<tr class="separator:aebc325909bbab691b330b7764e051bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47cc944240adf9ffd3e17c20b70861b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae47cc944240adf9ffd3e17c20b70861b">CreateSamplerSurface2DUP</a> (CmSurface2DUP *surface2dUP, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;samplerSurfaceIndex)=0</td></tr>
<tr class="memdesc:ae47cc944240adf9ffd3e17c20b70861b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a sampler surface index by a CmSurface2DUP.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae47cc944240adf9ffd3e17c20b70861b">More...</a><br /></td></tr>
<tr class="separator:ae47cc944240adf9ffd3e17c20b70861b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26b2d0596d84b103f1738d60ec2a6c0"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af26b2d0596d84b103f1738d60ec2a6c0">CloneKernel</a> (CmKernel *&amp;kernelDst, CmKernel *kernelSrc)=0</td></tr>
<tr class="memdesc:af26b2d0596d84b103f1738d60ec2a6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of source kernel to a new kernel.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af26b2d0596d84b103f1738d60ec2a6c0">More...</a><br /></td></tr>
<tr class="separator:af26b2d0596d84b103f1738d60ec2a6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3590a385f6fc9c5c82359833a0f13b7"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad3590a385f6fc9c5c82359833a0f13b7">CreateSurface2DAlias</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *p2DSurface, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;aliasSurfaceIndex)=0</td></tr>
<tr class="memdesc:ad3590a385f6fc9c5c82359833a0f13b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an alias to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ad3590a385f6fc9c5c82359833a0f13b7">More...</a><br /></td></tr>
<tr class="separator:ad3590a385f6fc9c5c82359833a0f13b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef8f459c6d1a4aa78443ff53c3f8893"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#abef8f459c6d1a4aa78443ff53c3f8893">CreateHevcVmeSurfaceG10</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *currentSurface, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **forwardSurfaces, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **backwardSurfaces, const uint32_t forwardSurfaceCount, const uint32_t backwardSurfaceCount, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;vmeIndex)=0</td></tr>
<tr class="memdesc:abef8f459c6d1a4aa78443ff53c3f8893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an HEVC VME surface by using the given 2D surfaces: the current frame, the forward frames and, the backward frames.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#abef8f459c6d1a4aa78443ff53c3f8893">More...</a><br /></td></tr>
<tr class="separator:abef8f459c6d1a4aa78443ff53c3f8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af236d2a670cacf9e09ca50199ef19e58"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af236d2a670cacf9e09ca50199ef19e58">DestroyHevcVmeSurfaceG10</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;vmeIndex)=0</td></tr>
<tr class="memdesc:af236d2a670cacf9e09ca50199ef19e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an HEVC VME surface. This can be used for Gen10.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af236d2a670cacf9e09ca50199ef19e58">More...</a><br /></td></tr>
<tr class="separator:af236d2a670cacf9e09ca50199ef19e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a980234eacf1dc8affd964db2174dc"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a80a980234eacf1dc8affd964db2174dc">CreateSamplerEx</a> (const CM_SAMPLER_STATE_EX &amp;sampleState, CmSampler *&amp;sampler)=0</td></tr>
<tr class="memdesc:a80a980234eacf1dc8affd964db2174dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSampler object with border color setting.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a80a980234eacf1dc8affd964db2174dc">More...</a><br /></td></tr>
<tr class="separator:a80a980234eacf1dc8affd964db2174dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811ccf4c380a39ef37fb7a5a7b058e3b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a811ccf4c380a39ef37fb7a5a7b058e3b">FlushPrintBufferIntoFile</a> (const char *filename)=0</td></tr>
<tr class="memdesc:a811ccf4c380a39ef37fb7a5a7b058e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prints the message dumped by kernel into file instead of stdout.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a811ccf4c380a39ef37fb7a5a7b058e3b">More...</a><br /></td></tr>
<tr class="separator:a811ccf4c380a39ef37fb7a5a7b058e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893a8e4db39c353dc39ff20917925bb3"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a893a8e4db39c353dc39ff20917925bb3">CreateThreadGroupSpaceEx</a> (uint32_t thrdSpaceWidth, uint32_t thrdSpaceHeight, uint32_t thrdSpaceDepth, uint32_t grpSpaceWidth, uint32_t grpSpaceHeight, uint32_t grpSpaceDepth, CmThreadGroupSpace *&amp;threadGroupSpace)=0</td></tr>
<tr class="memdesc:a893a8e4db39c353dc39ff20917925bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3-dimensional thread group space object.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a893a8e4db39c353dc39ff20917925bb3">More...</a><br /></td></tr>
<tr class="separator:a893a8e4db39c353dc39ff20917925bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b7c3cc0650afd933472bc670e0a0fa"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af2b7c3cc0650afd933472bc670e0a0fa">CreateSampler8x8SurfaceEx</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *surface2d, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;sampler8x8SurfIndex, CM_SAMPLER8x8_SURFACE surfType=CM_VA_SURFACE, CM_SURFACE_ADDRESS_CONTROL_MODE addressControl=CM_SURFACE_CLAMP, CM_FLAG *flag=nullptr)=0</td></tr>
<tr class="memdesc:af2b7c3cc0650afd933472bc670e0a0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSampler8x8 surface by using given 2D surface and given flags.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af2b7c3cc0650afd933472bc670e0a0fa">More...</a><br /></td></tr>
<tr class="separator:af2b7c3cc0650afd933472bc670e0a0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90e71ee619fd0d028a6d2d6a4eb64ab"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae90e71ee619fd0d028a6d2d6a4eb64ab">CreateSamplerSurface2DEx</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *surface2d, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;samplerSurfaceIndex, CM_FLAG *flag=nullptr)=0</td></tr>
<tr class="memdesc:ae90e71ee619fd0d028a6d2d6a4eb64ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates sampler surface by using given 2D surface and flags.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae90e71ee619fd0d028a6d2d6a4eb64ab">More...</a><br /></td></tr>
<tr class="separator:ae90e71ee619fd0d028a6d2d6a4eb64ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372192f31c5d0052f8a398da13860e77"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a372192f31c5d0052f8a398da13860e77">CreateBufferAlias</a> (CmBuffer *buffer, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;aliasIndex)=0</td></tr>
<tr class="memdesc:a372192f31c5d0052f8a398da13860e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an alias to CmBuffer.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a372192f31c5d0052f8a398da13860e77">More...</a><br /></td></tr>
<tr class="separator:a372192f31c5d0052f8a398da13860e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982a91f8c9b2d4c8591308b8929e563d"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a982a91f8c9b2d4c8591308b8929e563d">SetVmeSurfaceStateParam</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *vmeIndex, CM_VME_SURFACE_STATE_PARAM *surfStateParam)=0</td></tr>
<tr class="memdesc:a982a91f8c9b2d4c8591308b8929e563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the width and height values in the VME surface state.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a982a91f8c9b2d4c8591308b8929e563d">More...</a><br /></td></tr>
<tr class="separator:a982a91f8c9b2d4c8591308b8929e563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b622b07cc3ee52c868d5c46793013d"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a38b622b07cc3ee52c868d5c46793013d">GetVISAVersion</a> (uint32_t &amp;majorVersion, uint32_t &amp;minorVersion)=0</td></tr>
<tr class="memdesc:a38b622b07cc3ee52c868d5c46793013d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the VISA version up-to which IGC supports.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a38b622b07cc3ee52c868d5c46793013d">More...</a><br /></td></tr>
<tr class="separator:a38b622b07cc3ee52c868d5c46793013d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd907f8dc94b3b0245aba2cb1f4f667"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a9dd907f8dc94b3b0245aba2cb1f4f667">CreateQueueEx</a> (CmQueue *&amp;queue, CM_QUEUE_CREATE_OPTION QueueCreateOption=CM_DEFAULT_QUEUE_CREATE_OPTION)=0</td></tr>
<tr class="memdesc:a9dd907f8dc94b3b0245aba2cb1f4f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmQueue object with option.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a9dd907f8dc94b3b0245aba2cb1f4f667">More...</a><br /></td></tr>
<tr class="separator:a9dd907f8dc94b3b0245aba2cb1f4f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54f021faa2fc49d62ba553e744f273b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af54f021faa2fc49d62ba553e744f273b">UpdateBuffer</a> (<a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a> mosResource, CmBuffer *&amp;surface, MOS_HW_RESOURCE_DEF mosUsage=MOS_CM_RESOURCE_USAGE_SurfaceState)=0</td></tr>
<tr class="memdesc:af54f021faa2fc49d62ba553e744f273b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the MOS Resource in the CmBuffer. If surface is null, creates a new CmBuffer.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#af54f021faa2fc49d62ba553e744f273b">More...</a><br /></td></tr>
<tr class="separator:af54f021faa2fc49d62ba553e744f273b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fe95387d193d0232c0f25646288428"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aa3fe95387d193d0232c0f25646288428">UpdateSurface2D</a> (<a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a> mosResource, <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;surface, MOS_HW_RESOURCE_DEF mosUsage=MOS_CM_RESOURCE_USAGE_SurfaceState)=0</td></tr>
<tr class="memdesc:aa3fe95387d193d0232c0f25646288428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the MOS Resource in the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. If surface is null, creates a new <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#aa3fe95387d193d0232c0f25646288428">More...</a><br /></td></tr>
<tr class="separator:aa3fe95387d193d0232c0f25646288428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4639923ae9f1a6a80bdfd7a490a66dc5"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a4639923ae9f1a6a80bdfd7a490a66dc5">CreateSampler8x8SurfaceFromAlias</a> (<a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *originalSurface, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *aliasIndex, CM_SURFACE_ADDRESS_CONTROL_MODE addressControl, <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;sampler8x8SurfaceIndex)=0</td></tr>
<tr class="memdesc:a4639923ae9f1a6a80bdfd7a490a66dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CmSampler8x8 surface from Surface2D alias.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a4639923ae9f1a6a80bdfd7a490a66dc5">More...</a><br /></td></tr>
<tr class="separator:a4639923ae9f1a6a80bdfd7a490a66dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67729d56373c23def22b4f1786265e92"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a67729d56373c23def22b4f1786265e92">CreateBufferStateless</a> (size_t <a class="el" href="../../d8/df7/i915__drm__prelim_8h.html#a778fb2df652488eb52045d01ab72f0e1">size</a>, uint32_t option, void *sysMem, CmBufferStateless *&amp;bufferStateless)=0</td></tr>
<tr class="memdesc:a67729d56373c23def22b4f1786265e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">It creates a CmBufferStateless of the specified size in bytes by using the vedio memory or the system memory.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a67729d56373c23def22b4f1786265e92">More...</a><br /></td></tr>
<tr class="separator:a67729d56373c23def22b4f1786265e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40c182e6abb5c9ae36ef1fc93cfdd36"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae40c182e6abb5c9ae36ef1fc93cfdd36">DestroyBufferStateless</a> (CmBufferStateless *&amp;bufferStateless)=0</td></tr>
<tr class="memdesc:ae40c182e6abb5c9ae36ef1fc93cfdd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy CmBufferStateless object and associated vedio/system memory.  <a href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#ae40c182e6abb5c9ae36ef1fc93cfdd36">More...</a><br /></td></tr>
<tr class="separator:ae40c182e6abb5c9ae36ef1fc93cfdd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> class @UMD for Linux. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d64/cm__device_8h_source.html#l00055">55</a> of file <a class="el" href="../../d8/d64/cm__device_8h_source.html">cm_device.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="af26b2d0596d84b103f1738d60ec2a6c0" name="af26b2d0596d84b103f1738d60ec2a6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26b2d0596d84b103f1738d60ec2a6c0">&#9670;&nbsp;</a></span>CloneKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CloneKernel </td>
          <td>(</td>
          <td class="paramtype">CmKernel *&amp;&#160;</td>
          <td class="paramname"><em>kernelDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmKernel *&#160;</td>
          <td class="paramname"><em>kernelSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of source kernel to a new kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">kernelDst</td><td>pointer to the destination kernel. The new pointer will be returned to kernelDst. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernelSrc</td><td>pointer to the source kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>If the clone operation is successful. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>If the clone operation is failed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported in emulation mode. </dd></dl>

</div>
</div>
<a id="a761b9add31d2fa628fc8d6d8868e3455" name="a761b9add31d2fa628fc8d6d8868e3455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761b9add31d2fa628fc8d6d8868e3455">&#9670;&nbsp;</a></span>CreateBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a>&#160;</td>
          <td class="paramname"><em>mosResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmBuffer *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmBuffer from an existing MOS Resource. </p>
<p >CmBuffer is a wrapper of that MOS resource. This Mos resource is owned by caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mosResource</td><td>pointer to MOS resource. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>reference to pointer of surface to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmBuffer is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_MOS_RESOURCE_HANDLE</td><td>if mosResource is nullptr. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 1D surfaces is exceeded. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac7587352bbf001632edfc105ebf6b4a" name="aac7587352bbf001632edfc105ebf6b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7587352bbf001632edfc105ebf6b4a">&#9670;&nbsp;</a></span>CreateBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmBuffer *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmBuffer with specified size in bytes. </p>
<p >This function creates a buffer in video memory with linear layout. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Buffer size in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface</td><td>Reference to the pointer to the CmBuffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmBuffer is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if creating the underneath 1D surface fails. </td></tr>
    <tr><td class="paramname">CM_INVALID_WIDTH</td><td>if width is less than CM_MIN_SURF_WIDTH or larger than CM_MAX_1D_SURF_WIDTH. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 1D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_BUFFER_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a372192f31c5d0052f8a398da13860e77" name="a372192f31c5d0052f8a398da13860e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372192f31c5d0052f8a398da13860e77">&#9670;&nbsp;</a></span>CreateBufferAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateBufferAlias </td>
          <td>(</td>
          <td class="paramtype">CmBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>aliasIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an alias to CmBuffer. </p>
<p >Returns a new surface index for this surface. This API is used with CmBuffer::SetSurfaceStateParam in order to reinterpret buffer for different surface states, i.e., the same memory is used but different size can be programmed through the surface state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to CmBuffer object used to create an alias. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aliasIndex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if alias is created successfully. new surface index pointing to CmBuffer. </td></tr>
    <tr><td class="paramname">CM_EXCEED_MAX_NUM_BUFFER_ALIASES</td><td>if try to create more than 10 aliases for same surface. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>if alias cannot be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not implemented for EMU mode. </dd></dl>

</div>
</div>
<a id="a67729d56373c23def22b4f1786265e92" name="a67729d56373c23def22b4f1786265e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67729d56373c23def22b4f1786265e92">&#9670;&nbsp;</a></span>CreateBufferStateless()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateBufferStateless </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmBufferStateless *&amp;&#160;</td>
          <td class="paramname"><em>bufferStateless</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It creates a CmBufferStateless of the specified size in bytes by using the vedio memory or the system memory. </p>
<p >The stateless buffer means it is stateless-accessed by GPU. There are two ways to create a stateless buffer. One is to create from vedio memory, then it can be only accessed by GPU. The other way is to create from system memory, then it can be accessed by both GPU and CPU. In this way, The system memory will be allocated in runtime internally(if user pass nullptr pointer) or user provided (if user pass a valid pointer). And the system memory should be page aligned (4K bytes). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Stateless buffer size in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Stateless buffer create option. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMem</td><td>Pointer to user provided system memory if option is system memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pSurface</td><td>Reference to the pointer to the CmBufferStateless. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmBufferStateless is successfully created. </td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if creating the underneath 1D surface fails. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if runtime can't allocate such size system memory. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 1D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_BUFFER_COUNT. </td></tr>
    <tr><td class="paramname">CM_INVALID_CREATE_OPTION_FOR_BUFFER_STATELESS</td><td>if option is invalid. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd99e0eaf3cff957fd05eaebe6eeefa3" name="abd99e0eaf3cff957fd05eaebe6eeefa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd99e0eaf3cff957fd05eaebe6eeefa3">&#9670;&nbsp;</a></span>CreateBufferSVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateBufferSVM </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&amp;&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>accessFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmBufferSVM *&amp;&#160;</td>
          <td class="paramname"><em>bufferSVM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It creates a CmBufferSVM of the specified size in bytes by using the SVM (shared virtual memory) system memory. (<a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol05-memory_views.pdf">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol05-memory_views.pdf</a>). </p>
<p >The SVM memory can be accessed by both CPU and GPU. The SVM memory will be allocated in runtime internally(if user pass
            nullptr pointer) or user provided (if user pass a valid pointer). In both way, the memory should be page aligned (4K bytes). And the staring address is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>SVM buffer size in bytes. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pSystMem</td><td>Pointer to the SVM memory starting address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessFlag</td><td>Buffer access flags. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferSVM</td><td>Reference to the pointer to the CmBufferSVM. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmBufferSVM is successfully created. </td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if creating the underneath 1D surface fails. </td></tr>
    <tr><td class="paramname">CM_INVALID_WIDTH</td><td>if width is less than CM_MIN_SURF_WIDTH or larger than CM_MAX_1D_SURF_WIDTH. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if runtime can't allocate such size SVM memory. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 1D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_BUFFER_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not implemented in Linux for now. </dd></dl>

</div>
</div>
<a id="ad82e7e9569684292a34def52a77abab1" name="ad82e7e9569684292a34def52a77abab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad82e7e9569684292a34def52a77abab1">&#9670;&nbsp;</a></span>CreateBufferUP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateBufferUP </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmBufferUP *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmBufferUP object. </p>
<p >This API creates a CmBufferUP object on top of the UP (User Provided) system memory with specificed size in bytes. The UP memory starting address must be page (4K Bytes) aligned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>BufferUP size in bytes, the valid range is: &gt; CM_MIN_SURF_WIDTH, and &lt; CM_MAX_1D_SURF_WIDTH. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSystMem</td><td>Pointer to the system memory. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface</td><td>Reference to the pointer to the CmBufferUP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmBufferUP is successfully created. </td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if creating the underneath 1D surface fails. </td></tr>
    <tr><td class="paramname">CM_INVALID_WIDTH</td><td>if width is less than CM_MIN_SURF_WIDTH or larger than CM_MAX_1D_SURF_WIDTH. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if pSystMem is nullptr. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 1D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_BUFFER_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Application can access the memory though the memory point from CPU; can also access the buffer created upon the same memory from GPU. It is application's responsibility to make sure accesses from both sides are not overlapped. </dd>
<dd>
Refer to "MDF Host Programming Guide" for detailed usages. </dd></dl>

</div>
</div>
<a id="abef8f459c6d1a4aa78443ff53c3f8893" name="abef8f459c6d1a4aa78443ff53c3f8893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef8f459c6d1a4aa78443ff53c3f8893">&#9670;&nbsp;</a></span>CreateHevcVmeSurfaceG10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateHevcVmeSurfaceG10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>currentSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **&#160;</td>
          <td class="paramname"><em>forwardSurfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **&#160;</td>
          <td class="paramname"><em>backwardSurfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>forwardSurfaceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>backwardSurfaceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>vmeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an HEVC VME surface by using the given 2D surfaces: the current frame, the forward frames and, the backward frames. </p>
<p >No extra surface is actually created. A <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object is created instead, which is passed to CM kernel function (genx_main) as argument to indicate the frame surface. This can be used for Gen10 and plus platforms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentSurface</td><td>Pointer to current surface (can't be nullptr). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forwardSurfaces</td><td>Array of forward surfaces (can be nullptr if backward surfaces not a nullptr). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backwardSurfaces</td><td>Array of backward surfaces (can be nullptr if forward surfaces not a nullptr). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forwardSurfaceCount</td><td>Count of forward surfaces, up to 4 forward surfaces can be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backwardSurfaceCount</td><td>Count of backward surfaces, up to 4 backward surfaces can be used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vmeIndex</td><td>Reference to pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> is successfully created. </td></tr>
    <tr><td class="paramname">CM_NULL_POINTER</td><td>if currentSurface is nullptr. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if invalid surface pointers for forward and backward surfaces. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if there is too much co-existed surfaces are created. Destroying unused surfaces to solve such error. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is only supported for Gen10 and plus platforms. </dd></dl>

</div>
</div>
<a id="a6541fc359f7663966aca36c0f71a7c79" name="a6541fc359f7663966aca36c0f71a7c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541fc359f7663966aca36c0f71a7c79">&#9670;&nbsp;</a></span>CreateKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateKernel </td>
          <td>(</td>
          <td class="paramtype">CmProgram *&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>kernelName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmKernel *&amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmKernel object from the CmProgram object. </p>
<p >A Cmprogram can contains multiple kernels. The size of all arguments of a kernel should be no more than CAP_ARG_SIZE_PER_KERNEL byte. The number of all kernel arguments should be no more than CAP_ARG_COUNT_PER_KERNEL. The size of kernel binary should be no more than CAP_KERNEL_BINARY_SIZE bytes. The kernelName should be no more than 256 (CM_MAX_KERNEL_NAME_SIZE_IN_BYTE) bytes including the null terminator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">program</td><td>CmProgram object from which the kernel is created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernelName</td><td>CM kernel function (genx_main) name. A CM_KERNEL_FUNCTION macro MUST be used to specify this argument. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">kernel</td><td>Reference to the pointer to the CmKernel object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>JIT options for this specific kernel, overwriting the JIT options specified for all kernels in the CmProgram. This argument is optional. Size of options should be no more than 512 (CM_MAX_OPTION_SIZE_IN_BYTE) bytes including the null terminator. No options available for now. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmKernel is successfully created or returned. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if the program is an invalid pointer. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_EXCEED_KERNEL_ARG_AMOUNT</td><td>if the argument number of the kernel fucntion is larger than CAP_ARG_COUNT_PER_KERNEL. </td></tr>
    <tr><td class="paramname">CM_EXCEED_KERNEL_ARG_SIZE_IN_BYTE</td><td>if the argument size of the kernel fucntion is larger than CAP_ARG_SIZE_PER_KERNEL. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad262813c3aa97907feab9b651e8b990b" name="ad262813c3aa97907feab9b651e8b990b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad262813c3aa97907feab9b651e8b990b">&#9670;&nbsp;</a></span>CreateQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateQueue </td>
          <td>(</td>
          <td class="paramtype">CmQueue *&amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a task queue. </p>
<p >CmQueue is an in-order queue of tasks. Each task is essentially a CmTask object containing kernels that are to be run concurrently. Each kernel can be executed with multiple threads. Only one CmQueue is supported per <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> for now. Trying to create a second CmQueue will return a previously created CmQueue object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">queue</td><td>Reference to the pointer to the CmQueue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmQueue is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dd907f8dc94b3b0245aba2cb1f4f667" name="a9dd907f8dc94b3b0245aba2cb1f4f667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd907f8dc94b3b0245aba2cb1f4f667">&#9670;&nbsp;</a></span>CreateQueueEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateQueueEx </td>
          <td>(</td>
          <td class="paramtype">CmQueue *&amp;&#160;</td>
          <td class="paramname"><em>queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_QUEUE_CREATE_OPTION&#160;</td>
          <td class="paramname"><em>QueueCreateOption</em> = <code>CM_DEFAULT_QUEUE_CREATE_OPTION</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmQueue object with option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">queue</td><td>Pointer to the CmQueue object created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">QueueCreateOption</td><td>The option to create a queue. The sturcture of the <b>QueueCreateOption</b> is:<br  />
 <div class="fragment"><div class="line"><span class="keyword">struct </span>CM_QUEUE_CREATE_OPTION</div>
<div class="line">{</div>
<div class="line">    CM_QUEUE_TYPE QueueType : 3;</div>
<div class="line">    <span class="keywordtype">bool</span> RA       : 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Reserved0  : 3;</div>
<div class="line">    <span class="keywordtype">bool</span> UserGPUContext     : 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> GPUContext : 8;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Reserved2  : 16;</div>
<div class="line">}</div>
</div><!-- fragment --> <br  />
 <b>CM_QUEUE_TYPE</b> indicates which engine the queue will be created for:<br  />
 <div class="fragment"><div class="line"><span class="keyword">enum</span> CM_QUEUE_TYPE</div>
<div class="line">{</div>
<div class="line">    CM_QUEUE_TYPE_NONE      = 0,</div>
<div class="line">    CM_QUEUE_TYPE_RENDER    = 1,</div>
<div class="line">    CM_QUEUE_TYPE_COMPUTE   = 2,</div>
<div class="line">    CM_QUEUE_TYPE_VEBOX     = 3</div>
<div class="line">};</div>
</div><!-- fragment --> <br  />
 <b>RAMode</b> decides if the queue will occupy GPU exclusively during execution.<br  />
 <b>UserGPUContext</b> indicates if the user wants to provide an existing MOS GPU Context.<br  />
 <b>GPUContext</b> is the existing MOS GPU Context Enum value. <br  />
 <b>CM_QUEUE_SSEU_USAGE_HINT_TYPE</b> indicates SSEU setting, will be created for:<br  />
 <div class="fragment"><div class="line"><span class="keyword">enum</span> CM_QUEUE_SSEU_USAGE_HINT_TYPE</div>
<div class="line">{</div>
<div class="line">    CM_QUEUE_SSEU_USAGE_HINT_DEFAULT = 0,</div>
<div class="line">    CM_QUEUE_SSEU_USAGE_HINT_VME     = 1</div>
<div class="line">};</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmQueue object is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is implemented in hardware mode only. Only CM_QUEUE_TYPE_RENDER and CM_QUEUE_TYPE_COMPUTE are implemented at this moment. </dd></dl>

</div>
</div>
<a id="a09cd0035b7680aca2adb9461b9da70c8" name="a09cd0035b7680aca2adb9461b9da70c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cd0035b7680aca2adb9461b9da70c8">&#9670;&nbsp;</a></span>CreateSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSampler </td>
          <td>(</td>
          <td class="paramtype">const CM_SAMPLER_STATE &amp;&#160;</td>
          <td class="paramname"><em>sampleState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmSampler *&amp;&#160;</td>
          <td class="paramname"><em>sampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSampler object. </p>
<p >This function creates a 3D sampler state object used to sample a 2D surface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleState</td><td>Const reference to a CM_SAMPLER_STATE specifying the characteristics of the sampler to be created. The structure is defined below. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampler</td><td>Reference to the pointer to the CmSampler object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SAMPLER_AMOUNT</td><td>if maximum amount of sampler is exceeded. The amount is the amount of the sampler that can co-exist. The amount can be obtained by querying the cap CAP_SAMPLER_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>typedef struct _CM_SAMPLER_STATE<br  />
 {<br  />
 CM_TEXTURE_FILTER_TYPE minFilterType;<br  />
 CM_TEXTURE_FILTER_TYPE magFilterType;<br  />
 CM_TEXTURE_ADDRESS_TYPE addressU;<br  />
 CM_TEXTURE_ADDRESS_TYPE addressV;<br  />
 CM_TEXTURE_ADDRESS_TYPE addressW;<br  />
 } CM_SAMPLER_STATE;<br  />
 For now, only linear and anisotropic filter types are supported for hardware and simulation modes. For emulation mode, linear filter type is supported. Wrap, mirror, and clamp address types are supported in hardware and simulation modes. only clamp address type is supported in emulation mode. </dd></dl>

</div>
</div>
<a id="a71b04b93e9fe28a7bf5f80fed4c2c84e" name="a71b04b93e9fe28a7bf5f80fed4c2c84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b04b93e9fe28a7bf5f80fed4c2c84e">&#9670;&nbsp;</a></span>CreateSampler8x8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSampler8x8 </td>
          <td>(</td>
          <td class="paramtype">const CM_SAMPLER_8X8_DESCR &amp;&#160;</td>
          <td class="paramname"><em>sampler8x8Descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmSampler8x8 *&amp;&#160;</td>
          <td class="paramname"><em>sampler8x8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSampler8x8 object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampler8x8Descriptor</td><td>Const reference to a CM_SAMPLER_8X8_DESCR specifying the characteristics of the Sampler8x8 state to be created. Currently, AVS, VA Convolve and VA Misc( including MinMax Filter/Erode/Dilate ) states are supported. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampler8x8</td><td>Reference to the pointer to the CmSampler8x8 object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler8x8is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>wrong sampler8x8 type. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SAMPLER_AMOUNT</td><td>if the co-existed sampler exceeds maximum count which can be queried by CAP_SAMPLER_COUNT cap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16a2947cacd5c119dce23399577cbc5e" name="a16a2947cacd5c119dce23399577cbc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a2947cacd5c119dce23399577cbc5e">&#9670;&nbsp;</a></span>CreateSampler8x8Surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSampler8x8Surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>surface2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>sampler8x8SurfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SAMPLER8x8_SURFACE&#160;</td>
          <td class="paramname"><em>surfType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_ADDRESS_CONTROL_MODE&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSampler8x8 surface. </p>
<p >Creates a CmSampler8x8 surface by using the given 2D surface. The function indicates the 2D surface is used for sampler 8x8; no extra surface is actually created. A <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object is created instead, which is passed to CM kernel function (genx_main) as argument to indicate the surface for sampler 8x8. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface2d</td><td>Pointer to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampler8x8SurfIndex</td><td>Reference to pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfType</td><td>Enumeration data type of CM_SAMPLER8x8_SURFACE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Enumeration data type of CM_SURFACE_ADDRESS_CONTROL_MODE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler8x8 surface is successfully created. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if there is too many co-existed surfaces and exceed the maximum number. Destroying some unused surfaces could solve this error. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2b7c3cc0650afd933472bc670e0a0fa" name="af2b7c3cc0650afd933472bc670e0a0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b7c3cc0650afd933472bc670e0a0fa">&#9670;&nbsp;</a></span>CreateSampler8x8SurfaceEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSampler8x8SurfaceEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>surface2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>sampler8x8SurfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SAMPLER8x8_SURFACE&#160;</td>
          <td class="paramname"><em>surfType</em> = <code>CM_VA_SURFACE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_ADDRESS_CONTROL_MODE&#160;</td>
          <td class="paramname"><em>addressControl</em> = <code>CM_SURFACE_CLAMP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_FLAG *&#160;</td>
          <td class="paramname"><em>flag</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSampler8x8 surface by using given 2D surface and given flags. </p>
<p >The function indicates the 2D surface is used for sampler 8x8; no extra surface is actually created. A <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object is created instead, which is passed to CM kernel function(genx_main) as argument to indicate the surface for sampler 8x8. Compared to CmDeive::CreateSampler8x8Surface, this API is used to support rotation and chroma siting for MediaSampler. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface2d</td><td>Pointer to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampler8x8SurfIndex</td><td>Reference to pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfType</td><td>Enumeration data type of CM_SAMPLER8x8_SURFACE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressControl</td><td>Enumeration data type of CM_SURFACE_ADDRESS_CONTROL_MODE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Pointer to CM_FLAG. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler8x8 surface is successfully created. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if there is too many co-existed surfaces and exceed the maximum number. Destroying some unused surfaces could solve this error. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported in emulation mode. </dd></dl>

</div>
</div>
<a id="a4639923ae9f1a6a80bdfd7a490a66dc5" name="a4639923ae9f1a6a80bdfd7a490a66dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4639923ae9f1a6a80bdfd7a490a66dc5">&#9670;&nbsp;</a></span>CreateSampler8x8SurfaceFromAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSampler8x8SurfaceFromAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>originalSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&#160;</td>
          <td class="paramname"><em>aliasIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_ADDRESS_CONTROL_MODE&#160;</td>
          <td class="paramname"><em>addressControl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>sampler8x8SurfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSampler8x8 surface from Surface2D alias. </p>
<p >Creates a CmSampler8x8 surface by using the given 2D surface alias. No extra surface is actually created. A <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object is created instead, which is passed to CM kernel function (genx_main) as an argument to indicate the surface for AVS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">originalSurface</td><td>Pointer to the original <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aliasIndex</td><td>Surface alias upon which the output surface index is created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addressControl</td><td>Enumerator specifying address control mode used by AVS. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampler8x8SurfaceIndex</td><td>Sampler8x8 surface index created by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler8x8 surface is successfully created. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if there are too many surfaces, exceeding the maximum limit, </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory, </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80a980234eacf1dc8affd964db2174dc" name="a80a980234eacf1dc8affd964db2174dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a980234eacf1dc8affd964db2174dc">&#9670;&nbsp;</a></span>CreateSamplerEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSamplerEx </td>
          <td>(</td>
          <td class="paramtype">const CM_SAMPLER_STATE_EX &amp;&#160;</td>
          <td class="paramname"><em>sampleState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmSampler *&amp;&#160;</td>
          <td class="paramname"><em>sampler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSampler object with border color setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampleState</td><td>Const reference to a CM_SAMPLER_STATE_EX specifying the characteristics of the sampler to be created. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sampler</td><td>Reference to the pointer to the CmSampler object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SAMPLER_AMOUNT</td><td>if maximum amount of sampler is exceeded. The amount is the amount of the sampler that can co-exist. The amount can be obtained by querying the cap CAP_SAMPLER_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not implemented for EMU mode. <br  />
 Point, linear, and anisotropic filter types are supported for hardware and simulation modes. <br  />
 Wrap, mirror, clamp and border are supported in hardware and simulation modes. Clamp is supported in emulation mode. </dd></dl>

</div>
</div>
<a id="a1ea37539e05e12eef94463f9fe3cb230" name="a1ea37539e05e12eef94463f9fe3cb230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea37539e05e12eef94463f9fe3cb230">&#9670;&nbsp;</a></span>CreateSamplerSurface2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSamplerSurface2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>surface2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>samplerSurfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a sampler surface index by a given <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p >This sampler surface doesn't create any actual surface. It just binds the actual 2D surface with a virtual sampler surface index. User need pass this surface index as kernel argument if the surface is used for sampler, otherwise, the runtime will report error if user pass the 2D surface index. For the 2D surface format, for now supports following formats: <br  />
 CM_SURFACE_FORMAT_A16B16G16R16 <br  />
 CM_SURFACE_FORMAT_A16B16G16R16F <br  />
 CM_SURFACE_FORMAT_R32G32B32A32F <br  />
 CM_SURFACE_FORMAT_A8 <br  />
 CM_SURFACE_FORMAT_A8R8G8B8 <br  />
 CM_SURFACE_FORMAT_YUY2 <br  />
 CM_SURFACE_FORMAT_R32F <br  />
 CM_SURFACE_FORMAT_R32_UINT <br  />
 CM_SURFACE_FORMAT_L16 <br  />
 CM_SURFACE_FORMAT_R16G16_UNORM <br  />
 CM_SURFACE_FORMAT_R16_FLOAT <br  />
 CM_SURFACE_FORMAT_NV12 <br  />
 CM_SURFACE_FORMAT_L8 <br  />
 CM_SURFACE_FORMAT_AYUV <br  />
 CM_SURFACE_FORMAT_Y410 <br  />
 CM_SURFACE_FORMAT_Y416 <br  />
 CM_SURFACE_FORMAT_Y210 <br  />
 CM_SURFACE_FORMAT_Y216 <br  />
 CM_SURFACE_FORMAT_P010 <br  />
 CM_SURFACE_FORMAT_P016 <br  />
 CM_SURFACE_FORMAT_YV12 <br  />
 CM_SURFACE_FORMAT_411P <br  />
 CM_SURFACE_FORMAT_411R <br  />
 CM_SURFACE_FORMAT_IMC3 <br  />
 CM_SURFACE_FORMAT_I420 <br  />
 CM_SURFACE_FORMAT_422H <br  />
 CM_SURFACE_FORMAT_422V <br  />
 CM_SURFACE_FORMAT_444P <br  />
 CM_SURFACE_FORMAT_RGBP <br  />
 CM_SURFACE_FORMAT_BGRP <br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface2d</td><td>Pointer to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">samplerSurfaceIndex</td><td>Reference to the pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the new sampler surface index is successfully created. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the input surface format is not list above. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if the total number of co-existed surfaces are exceed maximum count. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae90e71ee619fd0d028a6d2d6a4eb64ab" name="ae90e71ee619fd0d028a6d2d6a4eb64ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90e71ee619fd0d028a6d2d6a4eb64ab">&#9670;&nbsp;</a></span>CreateSamplerSurface2DEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSamplerSurface2DEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>surface2d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>samplerSurfaceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_FLAG *&#160;</td>
          <td class="paramname"><em>flag</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates sampler surface by using given 2D surface and flags. </p>
<p >This sampler surface does't create any actual surface, and just bind the actual 2D surface with a virtual sampler surface index. User need pass this surface index as kernel argument if the surface is used for sampler, otherwise, the runtime will report error if user pass the 2D surface index. Compared to <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16a2947cacd5c119dce23399577cbc5e" title="Creates a CmSampler8x8 surface.">CmDevice::CreateSampler8x8Surface</a>, this API is used to support rotation for 3D sampler. For given surface's formats, for now, we support following: <br  />
 CM_SURFACE_FORMAT_A16B16G16R16 <br  />
 CM_SURFACE_FORMAT_A16B16G16R16F <br  />
 CM_SURFACE_FORMAT_R32G32B32A32F <br  />
 CM_SURFACE_FORMAT_A8 <br  />
 CM_SURFACE_FORMAT_A8R8G8B8 <br  />
 CM_SURFACE_FORMAT_YUY2 <br  />
 CM_SURFACE_FORMAT_R32F <br  />
 CM_SURFACE_FORMAT_R32_UINT <br  />
 CM_SURFACE_FORMAT_L16 <br  />
 CM_SURFACE_FORMAT_R16G16_UNORM <br  />
 CM_SURFACE_FORMAT_R16_FLOAT <br  />
 CM_SURFACE_FORMAT_NV12 <br  />
 CM_SURFACE_FORMAT_L8 <br  />
 CM_SURFACE_FORMAT_AYUV <br  />
 CM_SURFACE_FORMAT_Y410 <br  />
 CM_SURFACE_FORMAT_Y416 <br  />
 CM_SURFACE_FORMAT_Y210 <br  />
 CM_SURFACE_FORMAT_Y216 <br  />
 CM_SURFACE_FORMAT_P010 <br  />
 CM_SURFACE_FORMAT_P016 <br  />
 CM_SURFACE_FORMAT_YV12 <br  />
 CM_SURFACE_FORMAT_411P <br  />
 CM_SURFACE_FORMAT_411R <br  />
 CM_SURFACE_FORMAT_IMC3 <br  />
 CM_SURFACE_FORMAT_I420 <br  />
 CM_SURFACE_FORMAT_422H <br  />
 CM_SURFACE_FORMAT_422V <br  />
 CM_SURFACE_FORMAT_444P <br  />
 CM_SURFACE_FORMAT_RGBP <br  />
 CM_SURFACE_FORMAT_BGRP <br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface2d</td><td>Pointer to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">samplerSurfaceIndex</td><td>Reference to the pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Pointer to CM_FLAG. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the new sampler surface index is successfully created. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the input surface format is not list above. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if the total number of created co-existed surfaces are exceed maximum count. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is not supported in emulation mode. </dd></dl>

</div>
</div>
<a id="ae47cc944240adf9ffd3e17c20b70861b" name="ae47cc944240adf9ffd3e17c20b70861b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47cc944240adf9ffd3e17c20b70861b">&#9670;&nbsp;</a></span>CreateSamplerSurface2DUP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSamplerSurface2DUP </td>
          <td>(</td>
          <td class="paramtype">CmSurface2DUP *&#160;</td>
          <td class="paramname"><em>surface2dUP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>samplerSurfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a sampler surface index by a CmSurface2DUP. </p>
<p >This sampler surface doesn't create any actual surface, and just bind the actual 2D UP (User Provided) surface with a virtual sampler surface index. User need pass this surface index as kernel argument if the surface is used for sampler, otherwise, the runtime will report error if user pass the 2D UP surface index. For the 2DUP surface formats, for now supports following formats: <br  />
 CM_SURFACE_FORMAT_A16B16G16R16 <br  />
 CM_SURFACE_FORMAT_A8 <br  />
 CM_SURFACE_FORMAT_A8R8G8B8 <br  />
 CM_SURFACE_FORMAT_YUY2 <br  />
 CM_SURFACE_FORMAT_R32F <br  />
 CM_SURFACE_FORMAT_R32_UINT <br  />
 CM_SURFACE_FORMAT_L16 <br  />
 CM_SURFACE_FORMAT_R16G16_UNORM <br  />
 CM_SURFACE_FORMAT_NV12 <br  />
 CM_SURFACE_FORMAT_L8 <br  />
 CM_SURFACE_FORMAT_AYUV <br  />
 CM_SURFACE_FORMAT_Y410 <br  />
 CM_SURFACE_FORMAT_Y416 <br  />
 CM_SURFACE_FORMAT_Y210 <br  />
 CM_SURFACE_FORMAT_Y216 <br  />
 CM_SURFACE_FORMAT_P010 <br  />
 CM_SURFACE_FORMAT_P016 <br  />
 CM_SURFACE_FORMAT_YV12 <br  />
 CM_SURFACE_FORMAT_411P <br  />
 CM_SURFACE_FORMAT_411R <br  />
 CM_SURFACE_FORMAT_IMC3 <br  />
 CM_SURFACE_FORMAT_I420 <br  />
 CM_SURFACE_FORMAT_422H <br  />
 CM_SURFACE_FORMAT_422V <br  />
 CM_SURFACE_FORMAT_444P <br  />
 CM_SURFACE_FORMAT_RGBP <br  />
 CM_SURFACE_FORMAT_BGRP <br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface2dUP</td><td>Pointer to CmSurface2DUP object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">samplerSurfaceIndex</td><td>Reference to the pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the new sampler surface index is successfully created. </td></tr>
    <tr><td class="paramname">CM_NULL_POINTER</td><td>if p2DUPSurface is nullptr. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the format is not supported. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is supported for HW mode only. </dd></dl>

</div>
</div>
<a id="a16df972b7d4ea2715ae95a33703a9416" name="a16df972b7d4ea2715ae95a33703a9416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16df972b7d4ea2715ae95a33703a9416">&#9670;&nbsp;</a></span>CreateSamplerSurface3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSamplerSurface3D </td>
          <td>(</td>
          <td class="paramtype">CmSurface3D *&#160;</td>
          <td class="paramname"><em>surface3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>samplerSurfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a sampler surface index by a given CmSurface3D. </p>
<p >This function call doesn't create any actual surface. It just binds the actual 3D surface with a virtual sampler surface index. User need pass this surface index as kernel argument if the surface is used for sampler, otherwise, the runtime will report error if user pass the 3D surface index. For the 3D surface format, for now only supports the CM_SURFACE_FORMAT_A8R8G8B8 and CM_SURFACE_FORMAT_A16B16G16R16 formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface3d</td><td>Pointer to CmSurface3D object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">samplerSurfaceIndex</td><td>Reference to the pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the sampler surface index is successfully created. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the input surface format is not list above. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if the total number of created co-existed surfaces are exceed maximum count. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a896f952f65be2cd034d06385edaf279d" name="a896f952f65be2cd034d06385edaf279d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896f952f65be2cd034d06385edaf279d">&#9670;&nbsp;</a></span>CreateSurface2D() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSurface2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a>&#160;</td>
          <td class="paramname"><em>mosResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> from an existing MOS Resource. </p>
<p ><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is a wrapper of that MOS resource. This Mos resource is owned by caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mosResource</td><td>pointer to MOS resource. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>reference to pointer of surface to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_MOS_RESOURCE_HANDLE</td><td>if pMosResrouce is nullptr. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 2D surfaces is exceeded. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94604af1ac0cb113151d462d1d34fc45" name="a94604af1ac0cb113151d462d1d34fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94604af1ac0cb113151d462d1d34fc45">&#9670;&nbsp;</a></span>CreateSurface2D() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSurface2D </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_FORMAT&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> with given width, height, and format. </p>
<p >This function creates a surface in video memory with a 2D layout. User needs to provide width, height and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Surface width in pixel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Surface height in pixel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Surface format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface</td><td>Reference to the pointer to the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if creating the underneath resource fails. </td></tr>
    <tr><td class="paramname">CM_INVALID_WIDTH</td><td>if width is less than CM_MIN_SURF_WIDTH or larger than CM_MAX_2D_SURF_WIDTH, or for YUY2, or NV12 format, the width is odd. </td></tr>
    <tr><td class="paramname">CM_INVALID_HEIGHT</td><td>if height is less than CM_MIN_SURF_HEIGHT or larger than CM_MAX_2D_SURF_HEIGHT, or for NV12 format, the height is odd. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the format is not supported. The supported formats can be obtained by querying cap CAP_SURFACE2D_FORMAT_COUNT and CAP_SURFACE2D_FORMATS. For now, the following formats are supported: <br  />
 CM_SURFACE_FORMAT_A8R8G8B8, <br  />
 CM_SURFACE_FORMAT_X8R8G8B8, <br  />
 CM_SURFACE_FORMAT_A8B8G8R8, <br  />
 CM_SURFACE_FORMAT_R32F, <br  />
 CM_SURFACE_FORMAT_V8U8, <br  />
 CM_SURFACE_FORMAT_P8, <br  />
 CM_SURFACE_FORMAT_YUY2, <br  />
 CM_SURFACE_FORMAT_A8, <br  />
 CM_SURFACE_FORMAT_NV12, <br  />
 CM_SURFACE_FORMAT_P010, <br  />
 CM_SURFACE_FORMAT_UYVY, <br  />
 CM_SURFACE_FORMAT_IMC3, <br  />
 CM_SURFACE_FORMAT_411P, <br  />
 CM_SURFACE_FORMAT_422H, <br  />
 CM_SURFACE_FORMAT_422V, <br  />
 CM_SURFACE_FORMAT_444P, <br  />
 CM_SURFACE_FORMAT_YV12, <br  />
 CM_SURFACE_FORMAT_R8_UINT, <br  />
 CM_SURFACE_FORMAT_R16_UINT. <br  />
</td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 2D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_SURFACE2D_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For planar surface, there is only one <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> instance, no matter how many planes the surface may have. The detail about how to access different planes in the kernel code can be found in CM Language Spec, looking for read_plane and write_plane. </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_a94604af1ac0cb113151d462d1d34fc45_icgraph.png" border="0" usemap="#ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_a94604af1ac0cb113151d462d1d34fc45_icgraph" alt=""/></div>
<map name="ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_a94604af1ac0cb113151d462d1d34fc45_icgraph" id="ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_a94604af1ac0cb113151d462d1d34fc45_icgraph">
<area shape="rect" title="Creates a CmSurface2D with given width, height, and format." alt="" coords="193,5,353,47"/>
<area shape="rect" href="../../d0/df9/cm__surface__2d__wrapper_8cpp.html#a604a664eda3e9d930396577738f49423" title=" " alt="" coords="5,13,145,39"/>
</map>
</div>

</div>
</div>
<a id="ab176b4c08c43a2e7bd8c2056c6d8ccf9" name="ab176b4c08c43a2e7bd8c2056c6d8ccf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab176b4c08c43a2e7bd8c2056c6d8ccf9">&#9670;&nbsp;</a></span>CreateSurface2D() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSurface2D </td>
          <td>(</td>
          <td class="paramtype">VASurfaceID&#160;</td>
          <td class="paramname"><em>vaSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VADriverContext *&#160;</td>
          <td class="paramname"><em>vaDriverCtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> from an existing VA surface. </p>
<p >The application must have created the VA surface using the VADriverContext used to create <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a>. The VA surface format should be within the supported format set which can be obtained by querying cap CAP_SURFACE2D_FORMAT_COUNT and CAP_SURFACE2D_FORMATS. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vaSurface</td><td>indext to VA surface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vaDriverCtx</td><td>pointer to VA driver context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>reference to pointer of surface to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is successfully created. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 2D surfaces is exceeded. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3590a385f6fc9c5c82359833a0f13b7" name="ad3590a385f6fc9c5c82359833a0f13b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3590a385f6fc9c5c82359833a0f13b7">&#9670;&nbsp;</a></span>CreateSurface2DAlias()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSurface2DAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>p2DSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>aliasSurfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an alias to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p >Returns a new surface index for this surface. This API is used with <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ad102b650c163a3960c345ede98916cf7" title="Sets surface state parameters for an alias of this CmSurface2D.">CmSurface2D::SetSurfaceStateParam</a> in order to reinterpret surface for different surface states, i.e., the same memory is used but different width and height can be programmed through the surface state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p2DSurface</td><td>pointer to the surface used to create an alias. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aliasSurfaceIndex</td><td>new surface index pointing to 2D surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if alias is created successfully. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if p2DSurface is not a valid pointer. </td></tr>
    <tr><td class="paramname">CM_MAX_NUM_2D_ALIASES</td><td>if try to create more than 10 aliases for same surface. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is implemented for HW and SIM modes only. </dd></dl>

</div>
</div>
<a id="a43a3267c83ee9180ad71aaafcce61c8f" name="a43a3267c83ee9180ad71aaafcce61c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a3267c83ee9180ad71aaafcce61c8f">&#9670;&nbsp;</a></span>CreateSurface2DUP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSurface2DUP </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_FORMAT&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmSurface2DUP *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSurface2DUP object. </p>
<p >Creates a CmSurface2DUP in UP (User Provided) system memory with given surface width, height in pixel, and format. The UP system memory must be page (4K Bytes) aligned. The size of the system memory must larger than or equal to the size return by <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a8cbcddd96adb0e8f9f553b506a58ed2b" title="Gets Surface2D allocation information by given width, height, and format.">GetSurface2DInfo()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width in pixel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height in pixel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMem</td><td>Reference to the pointer to the system memory which is CPU accessible. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface</td><td>Reference to the pointer to the CmSurface2DUP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSurface2DUPis successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMem is nullptr. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_INVALID_WIDTH</td><td>if width is less than CM_MIN_SURF_WIDTH or larger than CM_MAX_2D_SURF_WIDTH, or for YUY2 or NV12 format, the width is odd. </td></tr>
    <tr><td class="paramname">CM_INVALID_HEIGHT</td><td>if height is less than CM_MIN_SURF_HEIGHT or larger than CM_MAX_2D_SURF_HEIGHT, or for NV12 format, the height is odd. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the format is not supported. The supported formats can be obtained by querying cap CAP_SURFACE2D_FORMAT_COUNT and CAP_SURFACE2D_FORMATS. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 2D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_SURFACE2D_COUNT. </td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if allocation is failed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Application can access the memory though the memory point returned from CPU; can also access the surface created upon the same memory from GPU. It is application's responsibility to make sure accesses from both sides are not overlapped. When accessing the system memory from CPU, the user needs to be aware about pitch, which is equal to (pixel_width * byte_per_pixel + necessary_padding). </dd>
<dd>
Refer to the CmSurface2DUP class for member APIs, and 'MDF runtime host programming guide' for usages. </dd></dl>

</div>
</div>
<a id="a026f83505fd025d89f1901bd1ce332eb" name="a026f83505fd025d89f1901bd1ce332eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026f83505fd025d89f1901bd1ce332eb">&#9670;&nbsp;</a></span>CreateSurface3D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateSurface3D </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_FORMAT&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmSurface3D *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmSurface3D with given width, height, depth and pixel format. </p>
<p >This function creates a surface in memory with a 3D layout. User needs to provide width, height, depth and format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Surface width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Surface height. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depth</td><td>Surface depth. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Surface format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">surface</td><td>Reference to the pointer to the CmSurface3D. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSurface3D is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_INVALID_WIDTH</td><td>if width is less than CM_MIN_SURF_WIDTH or larger than CM_MAX_3D_SURF_WIDTH. </td></tr>
    <tr><td class="paramname">CM_INVALID_HEIGHT</td><td>if height is less than CM_MIN_SURF_HEIGHT or larger than CM_MAX_3D_SURF_HEIGHT. </td></tr>
    <tr><td class="paramname">CM_INVALID_DEPTH</td><td>if width is less than CM_MIN_SURF_DEPTH or larger than CM_MAX_3D_SURF_DEPTH. </td></tr>
    <tr><td class="paramname">CM_SURFACE_FORMAT_NOT_SUPPORTED</td><td>if the format is not supported. The supported formats can be obtained by querying cap CAP_SURFACE3D_FORMAT_COUNT and CAP_SURFACE3D_FORMATS, For now, only supports: <br  />
 CM_SURFACE_FORMAT_X8R8G8B8, <br  />
 CM_SURFACE_FORMAT_A8R8G8B8, <br  />
 CM_SURFACE_FORMAT_A16B16G16R16. <br  />
</td></tr>
    <tr><td class="paramname">CM_SURFACE_ALLOCATION_FAILURE</td><td>if creating the underneath 3D surface fails. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 3D surfaces is exceeded. The amount is the amount of the surfaces that can co-exist. The amount can be obtained by querying the cap CAP_SURFACE3D_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aceea38761c0eadbd1bd6bf1966595f84" name="aceea38761c0eadbd1bd6bf1966595f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceea38761c0eadbd1bd6bf1966595f84">&#9670;&nbsp;</a></span>CreateTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateTask </td>
          <td>(</td>
          <td class="paramtype">CmTask *&amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmTask object. </p>
<p >This object is a container for one or multiple CmKernel objects, and used to enqueue the kernels for concurrent execution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">task</td><td>Reference to the pointer to the CmTask </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmTask is successfully created </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5fe60daf86914eedd6bf6e9a21a0d0b" name="ae5fe60daf86914eedd6bf6e9a21a0d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fe60daf86914eedd6bf6e9a21a0d0b">&#9670;&nbsp;</a></span>CreateThreadGroupSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateThreadGroupSpace </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadSpaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>threadSpaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>groupSpaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>groupSpaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmThreadGroupSpace *&amp;&#160;</td>
          <td class="paramname"><em>threadGroupSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a 2-dimensional thread group space object. </p>
<p >This function creates a thread group space specified by the height and width dimensions of the group space, and the height and width dimensions of the thread space within a group. This information is used to execute a kernel in GPGPU pipe (<a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol07-3d_media_gpgpu.pdf">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol07-3d_media_gpgpu.pdf</a>). Relevant sample code is shown in "MDF Host Programming Guide" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadSpaceWidth</td><td>width in unit of threads of each thread group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threadSpaceHeight</td><td>height in unit of threads of each thread group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">groupSpaceWidth</td><td>width in unit of groups of thread group space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">groupSpaceHeight</td><td>height in unit of groups of thread group space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadGroupSpace</td><td>Reference to the pointer to CmThreadGroupSpace object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmThreadGroupSpace is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_THREAD_GROUP_SPACE</td><td>if any input is 0 or the thrdSpaceWidth is more than MAX_THREAD_SPACE_WIDTH_PERGROUP, or the thrdSpaceHeight is more than MAX_THREAD_SPACE_HEIGHT_PERGROUP. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The total thread count is width*height*grpWidth*grpHeight. CmKernel::SetThreadCount() calling is not necessary in this GPGPU working mode. Currently, it's only used for SLM enabled kernels. See also <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a893a8e4db39c353dc39ff20917925bb3" title="Creates a 3-dimensional thread group space object.">CreateThreadGroupSpaceEx()</a> API which specifies a 3-dimensional thread group space with width, height and depth. </dd></dl>

</div>
</div>
<a id="a893a8e4db39c353dc39ff20917925bb3" name="a893a8e4db39c353dc39ff20917925bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893a8e4db39c353dc39ff20917925bb3">&#9670;&nbsp;</a></span>CreateThreadGroupSpaceEx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateThreadGroupSpaceEx </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thrdSpaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thrdSpaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>thrdSpaceDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>grpSpaceWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>grpSpaceHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>grpSpaceDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmThreadGroupSpace *&amp;&#160;</td>
          <td class="paramname"><em>threadGroupSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a 3-dimensional thread group space object. </p>
<p >This function creates a thread group space specified by the depth, height and width dimensions of the group space, and the depth, height and width dimensions of the thread space within a group. This information is used to execute a kernel in GPGPU pipe (<a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol07-3d_media_gpgpu.pdf">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol07-3d_media_gpgpu.pdf</a>). Relevant sample code is shown in "MDF Host Programming Guide". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thrdSpaceWidth</td><td>width in unit of threads of each thread group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thrdSpaceHeight</td><td>height in unit of threads of each thread group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thrdSpaceDepth</td><td>depth in unit of threads of each thread group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grpSpaceWidth</td><td>width in unit of groups of thread group space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grpSpaceHeight</td><td>height in unit of groups of thread group space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grpSpaceDepth</td><td>depth in unit of groups of thread group space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadGroupSpace</td><td>Reference to the pointer to CmThreadGroupSpace object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmThreadGroupSpace is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_THREAD_GROUP_SPACE</td><td>if any input is 0 or the thrdSpaceWidth is more than MAX_THREAD_SPACE_WIDTH_PERGROUP, or the thrdSpaceHeight is more than MAX_THREAD_SPACE_HEIGHT_PERGROUP, or the thrdSpaceDepth is more than MAX_THREAD_SPACE_DEPTH_PERGROUP. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The total thread count is width*height*depth*grpWidth*grpHeight*grpDepth. CmKernel::SetThreadCount() calling is not necessary in this GPGPU working mode. Currently, it's only used for SLM enabled kernels. </dd></dl>

</div>
</div>
<a id="a37cdf2a6f165d7db73b9b686f2e57784" name="a37cdf2a6f165d7db73b9b686f2e57784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cdf2a6f165d7db73b9b686f2e57784">&#9670;&nbsp;</a></span>CreateThreadSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateThreadSpace </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmThreadSpace *&amp;&#160;</td>
          <td class="paramname"><em>threadSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmThreadSpace object. </p>
<p >CmThreadSpace is a 2D space.Each unit is notated as a pair of X/Y coordinates, which is in the range of [0, width -1] or [0, heigh-1]. A thread space can define a dependency or no dependency. A thread space can be used as per-task thread space by passing it in Enqueue(), or be used as per-kernel thread space by calling CmKernel::AssociateThreadSpace() API. Please refer to "Host programming guide" for detailed thread space usages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Thread space width. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Thread space height. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">threadSpace</td><td>Reference to pointer to CmThreadSpace object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmThreadSpace is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_THREAD_SPACE</td><td>if the width or(and) height are </td></tr>
    <tr><td class="paramname">invalid</td><td>values (0 or exceeds maximum size). </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum width/height allowed when using media walker is 511 for pre-SKL and 2047 for SKL+. For media object the maximum width/height allowed is 512. </dd></dl>

</div>
</div>
<a id="a029356303e85c9d36f847d37b19ff768" name="a029356303e85c9d36f847d37b19ff768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029356303e85c9d36f847d37b19ff768">&#9670;&nbsp;</a></span>CreateVebox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateVebox </td>
          <td>(</td>
          <td class="paramtype">CmVebox *&amp;&#160;</td>
          <td class="paramname"><em>vebox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a VEBOX object for VEBOX operations (<a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol09-media_vebox.pdf">https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol09-media_vebox.pdf</a>). </p>
<p >Caller provides a reference of CmVebox pointer to get the CmVebox object created from this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vebox</td><td>the created VEBOX object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if creation is successfully. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of host memory. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6183a8afff1b703488b10a9cdb62ff29" name="a6183a8afff1b703488b10a9cdb62ff29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6183a8afff1b703488b10a9cdb62ff29">&#9670;&nbsp;</a></span>CreateVmeSurfaceG7_5()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::CreateVmeSurfaceG7_5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&#160;</td>
          <td class="paramname"><em>currentSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **&#160;</td>
          <td class="paramname"><em>forwardSurfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> **&#160;</td>
          <td class="paramname"><em>backwardSurfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>forwardSurfaceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>backwardSurfaceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>vmeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a VME surface for AVC messages in kernel. </p>
<p >Creates a VME surface by using the given 2D surfaces: the current frame, the forward frames and, the backward frames. The last two can be nullptr if not used. The function indicates these 2D surfaces are used for VME; no extra surface is actually created. A <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object is created instead, which is passed to CM kernel function (genx_main) as argument to indicate the frame surface. Please see VME examples in "MDF Host Programming Guide" document and CM language specification for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentSurface</td><td>Pointer to current surface (can't be nullptr). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forwardSurfaces</td><td>Array of forward surfaces (can be nullptr). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backwardSurfaces</td><td>Array of backward surfaces (can be nullptr). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forwardSurfaceCount</td><td>Count of forward surfaces, up to 16 forward surfaces can be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backwardSurfaceCount</td><td>Count of backward surfaces, up to 16 backward surfaces can be used. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vmeIndex</td><td>Reference to pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> is successfully created. </td></tr>
    <tr><td class="paramname">CM_NULL_POINTER</td><td>if currentSurface is nullptr. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if any parameter is not valid. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of VME surfaces is exceeded. The amount is the amount of VME surfaces that can co-exist. The amount can be obtained by querying the cap CAP_VME_SURFACE_COUNT. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This can be used for all Gen7_5 and plus platforms. </dd></dl>

</div>
</div>
<a id="ae40c182e6abb5c9ae36ef1fc93cfdd36" name="ae40c182e6abb5c9ae36ef1fc93cfdd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40c182e6abb5c9ae36ef1fc93cfdd36">&#9670;&nbsp;</a></span>DestroyBufferStateless()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyBufferStateless </td>
          <td>(</td>
          <td class="paramtype">CmBufferStateless *&amp;&#160;</td>
          <td class="paramname"><em>bufferStateless</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy CmBufferStateless object and associated vedio/system memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pSurface</td><td>Reference to the pointer pointing to CmBufferStateless, will be assigned to nullptr once it is destroyed successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmBufferStateless and associated vedio/system memory are successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebc325909bbab691b330b7764e051bf6" name="aebc325909bbab691b330b7764e051bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc325909bbab691b330b7764e051bf6">&#9670;&nbsp;</a></span>DestroyBufferSVM()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyBufferSVM </td>
          <td>(</td>
          <td class="paramtype">CmBufferSVM *&amp;&#160;</td>
          <td class="paramname"><em>bufferSVM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys CmBufferSVM object and associated SVM memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">bufferSVM</td><td>Reference to the pointer pointing to CmBufferSVM, will be assigned to nullptr once it is destroyed successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmBufferSVM and associated SVM meory are successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac97b05a1bec364934aa6045d0d0db068" name="ac97b05a1bec364934aa6045d0d0db068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97b05a1bec364934aa6045d0d0db068">&#9670;&nbsp;</a></span>DestroyBufferUP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyBufferUP </td>
          <td>(</td>
          <td class="paramtype">CmBufferUP *&amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys CmBufferUP object. </p>
<p >The UP (User Provided) memory is still existing after the CmBufferUP object is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>Reference to the pointer pointing to CmBufferUP. It will be assigned to nullptr once the function is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmBufferUP is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af236d2a670cacf9e09ca50199ef19e58" name="af236d2a670cacf9e09ca50199ef19e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af236d2a670cacf9e09ca50199ef19e58">&#9670;&nbsp;</a></span>DestroyHevcVmeSurfaceG10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyHevcVmeSurfaceG10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>vmeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys an HEVC VME surface. This can be used for Gen10. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vmeIndex</td><td>Pointer to the <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> of the VME surface. It will be assigned to nullptr once destroy is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the HEVC VME surface is successfully destroyed </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is only supported for Gen10 and plus platforms. <br  />
 Any HEVC VME surface not destroyed by calling this function explicitly will be destroyed when <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </dd></dl>

</div>
</div>
<a id="aacb232f4f08dcc2d7f7d2fcf0a44ad9c" name="aacb232f4f08dcc2d7f7d2fcf0a44ad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb232f4f08dcc2d7f7d2fcf0a44ad9c">&#9670;&nbsp;</a></span>DestroyKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyKernel </td>
          <td>(</td>
          <td class="paramtype">CmKernel *&amp;&#160;</td>
          <td class="paramname"><em>kernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a CmKernel. </p>
<p >A CmKernel that is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">kernel</td><td>CmKernel object to be destroyed. It will be assigned to nullptr once the fuction is return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmKernel is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12298eea2601ad1cc0a8a9389fa7c5d7" name="a12298eea2601ad1cc0a8a9389fa7c5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12298eea2601ad1cc0a8a9389fa7c5d7">&#9670;&nbsp;</a></span>DestroyProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyProgram </td>
          <td>(</td>
          <td class="paramtype">CmProgram *&amp;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a CmProgram. </p>
<p >A CmProgram that is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">program</td><td>Reference to the pointer to the CmProgram. It will be assigned to nullptr once the fuction is return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmProgram is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac637343990cc52934e4922ef1a8ee11" name="aac637343990cc52934e4922ef1a8ee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac637343990cc52934e4922ef1a8ee11">&#9670;&nbsp;</a></span>DestroySampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySampler </td>
          <td>(</td>
          <td class="paramtype">CmSampler *&amp;&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a CmSampler. </p>
<p >A CmSampler that is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sampler</td><td>A reference to the CmSampler pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1f6dd478dcfdad8c9abe5709d34e339" name="ac1f6dd478dcfdad8c9abe5709d34e339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f6dd478dcfdad8c9abe5709d34e339">&#9670;&nbsp;</a></span>DestroySampler8x8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySampler8x8 </td>
          <td>(</td>
          <td class="paramtype">CmSampler8x8 *&amp;&#160;</td>
          <td class="paramname"><em>sampler8x8State</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a CmSampler8x8 object. </p>
<p >A CmSampler8x8 which is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sampler8x8State</td><td>Reference to a sampler of CmSampler8x8. It will be assigned to nullptr once destroy is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler8x8 is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff8dbb1c5528ecc8e4f1885c9c8a69be" name="aff8dbb1c5528ecc8e4f1885c9c8a69be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8dbb1c5528ecc8e4f1885c9c8a69be">&#9670;&nbsp;</a></span>DestroySampler8x8Surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySampler8x8Surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>sampler8x8SurfIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a CmSampler8x8 surface. </p>
<p >A CmSampler8x8 surface which is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sampler8x8SurfIndex</td><td>Reference to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a>. It will be assigned to nullptr once destroy is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmSampler8x8 surface is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a179144894e0a224e857ba78b8623d5b5" name="a179144894e0a224e857ba78b8623d5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179144894e0a224e857ba78b8623d5b5">&#9670;&nbsp;</a></span>DestroySamplerSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySamplerSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>samplerSurfaceIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function destroys a sampler surface index created by <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a1ea37539e05e12eef94463f9fe3cb230" title="This function creates a sampler surface index by a given CmSurface2D.">CreateSamplerSurface2D()</a>, CreateSamplerSurface2DUP, or <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a16df972b7d4ea2715ae95a33703a9416" title="This function creates a sampler surface index by a given CmSurface3D.">CreateSamplerSurface3D()</a>. </p>
<p >Caller provides the reference of a pointer to the surface index needs t be destoryed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">samplerSurfaceIndex</td><td>Reference to the pointer to <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> object to be destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the sampler surface index is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1293d052930415e00d09f71352424cf" name="ae1293d052930415e00d09f71352424cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1293d052930415e00d09f71352424cf">&#9670;&nbsp;</a></span>DestroySurface() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySurface </td>
          <td>(</td>
          <td class="paramtype">CmBuffer *&amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys CmBuffer object. </p>
<p >This function destroys CmBuffer object. After the function is called, it will return immediately without waiting. If there is any Enqueue is being executed when this function is called, the actual destroy will be postponed internally by the runtime, and user doens't need to worry about it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>Reference to the pointer pointing to CmBuffer, it will be assigned to nullptr after destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmBuffer is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_ae1293d052930415e00d09f71352424cf_icgraph.png" border="0" usemap="#ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_ae1293d052930415e00d09f71352424cf_icgraph" alt=""/></div>
<map name="ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_ae1293d052930415e00d09f71352424cf_icgraph" id="ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_ae1293d052930415e00d09f71352424cf_icgraph">
<area shape="rect" title="Destroys CmBuffer object." alt="" coords="200,5,360,47"/>
<area shape="rect" href="../../d0/df9/cm__surface__2d__wrapper_8cpp.html#a86ae530529ce4e9bb237c715995aca7b" title=" " alt="" coords="5,13,152,39"/>
</map>
</div>

</div>
</div>
<a id="a7a45c921f36bd99a799397bff9888fe6" name="a7a45c921f36bd99a799397bff9888fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a45c921f36bd99a799397bff9888fe6">&#9670;&nbsp;</a></span>DestroySurface() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> type surface. </p>
<p >This function destroys <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> object. After the function is called, it will return immediately without waiting. If there is any Enqueue is being executed when this function is called, the actual destroy will be postponed internally by the runtime, and user doens't need to worry about it. One exception is that if the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> was created by a third party VA surface, user has to keep the VA surface until the kernel using it finishes execution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>Reference to the pointer pointing to <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. It will be assigned to nullptr after destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04e60536fd51c8f0a00388c1c2801f36" name="a04e60536fd51c8f0a00388c1c2801f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e60536fd51c8f0a00388c1c2801f36">&#9670;&nbsp;</a></span>DestroySurface() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySurface </td>
          <td>(</td>
          <td class="paramtype">CmSurface3D *&amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys CmSurface3D object. </p>
<p >This function destroys CmSurface3D object. After the function is called, it will return immediately without waiting. If there is any Enqueue is being executed when this function is called, the actual destroy will be postponed internally by the runtime, and user doens't need to worry about it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>Reference to the pointer pointing to CmSurface3D. It will be assigned to nullptr after destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmSurface3D is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ba048383eae043cf72c4134ab8549f5" name="a2ba048383eae043cf72c4134ab8549f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba048383eae043cf72c4134ab8549f5">&#9670;&nbsp;</a></span>DestroySurface2DUP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroySurface2DUP </td>
          <td>(</td>
          <td class="paramtype">CmSurface2DUP *&amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys CmSurface2DUP surface. </p>
<p >The UP (User Provided) memory is still existing after the CmSurface2DUP object is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>Reference to the pointer pointing to CmSurface2DUP. It will be assigned to nullptr once this function is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmSurface2DUPis successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31b8b85dbe6213b6abf934cd6b267324" name="a31b8b85dbe6213b6abf934cd6b267324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b8b85dbe6213b6abf934cd6b267324">&#9670;&nbsp;</a></span>DestroyTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyTask </td>
          <td>(</td>
          <td class="paramtype">CmTask *&amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a CmTask object. </p>
<p >A CmTask that is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">task</td><td>Reference to the pointer to the CmTask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmTaskis successfully destroyed </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a162b4a497286e284ac6af8c8158c683d" name="a162b4a497286e284ac6af8c8158c683d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162b4a497286e284ac6af8c8158c683d">&#9670;&nbsp;</a></span>DestroyThreadGroupSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyThreadGroupSpace </td>
          <td>(</td>
          <td class="paramtype">CmThreadGroupSpace *&amp;&#160;</td>
          <td class="paramname"><em>threadGroupSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the created thread group space object. </p>
<p >Caller provides the reference of thread group space pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadGroupSpace</td><td>Pointer to a CmThreadGroupSpace. It will be assigned to nullptr once destroy is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmThreadGroupSpace pointer is successfully destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>User can call this API to explicitly destroy CmThreadGroupSpace instance, otherwise, <a class="el" href="../../da/d12/cm__global__api__os_8cpp.html#a3ef394efa7be8e87e0c6ee158d8cb314" title="Destroys the CmDevice.">DestroyCmDevice()</a> takes care of all of such instances release. </dd></dl>

</div>
</div>
<a id="a7e42a440e8ec99761e3f35b719f23d75" name="a7e42a440e8ec99761e3f35b719f23d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e42a440e8ec99761e3f35b719f23d75">&#9670;&nbsp;</a></span>DestroyThreadSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyThreadSpace </td>
          <td>(</td>
          <td class="paramtype">CmThreadSpace *&amp;&#160;</td>
          <td class="paramname"><em>threadSpace</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a CmThreadSpace instance. </p>
<p >A CmThreadSpace that is not destroyed by calling this function will be destroyed when the <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">threadSpace</td><td>Reference to the pointer to the CmThreadSpace. It will be assigned to nullptr once the fuction is return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmThreadSpace is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>if the input is nullptr or not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc20c0af1a55bad977331986c73d1d56" name="abc20c0af1a55bad977331986c73d1d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc20c0af1a55bad977331986c73d1d56">&#9670;&nbsp;</a></span>DestroyVebox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyVebox </td>
          <td>(</td>
          <td class="paramtype">CmVebox *&amp;&#160;</td>
          <td class="paramname"><em>vebox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function destroys a VEBOX object. </p>
<p >Caller provides a reference of CmVebox pointer to destroy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vebox</td><td>The VEBOX object to be destroyed. It will be assigned to nullptr once destroy is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if creation is successfully. </td></tr>
    <tr><td class="paramname">CM_NULL_POINTER</td><td>if the vebox pointer is nullptr. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a03d756c9bd108c3fa393eae8c738e8" name="a6a03d756c9bd108c3fa393eae8c738e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a03d756c9bd108c3fa393eae8c738e8">&#9670;&nbsp;</a></span>DestroyVmeSurfaceG7_5()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::DestroyVmeSurfaceG7_5 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>vmeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a VME surface object. </p>
<p >Any VME surface not destroyed by calling this function explicitly will be destroyed when <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a> is destroyed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vmeIndex</td><td>Pointer to the <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> of the VME surface. It will be assigned to nullptr once destroy is done. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the VME surface is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This can be used for all Gen7_5 and plus platforms. </dd></dl>

</div>
</div>
<a id="a119687d90a19d1f7e9b18dfa5ae0cdc3" name="a119687d90a19d1f7e9b18dfa5ae0cdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119687d90a19d1f7e9b18dfa5ae0cdc3">&#9670;&nbsp;</a></span>FlushPrintBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::FlushPrintBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function prints the message on the standard display device that are dumped by kernel. </p>
<p >It should be called after the task being finished. The order of printf output is not deterministic due to thread scheduling and the fact that different threads may be interleaved. To distinguish which thread the printf string comes from, it is better to print the thread id as the first value. Alternatively you could always put the printf inside if statement that limits the printf to a given thread. If one task has more than one kernels call printf() , their outputs could mix together. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the buffer is flushed successfully. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a811ccf4c380a39ef37fb7a5a7b058e3b" name="a811ccf4c380a39ef37fb7a5a7b058e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811ccf4c380a39ef37fb7a5a7b058e3b">&#9670;&nbsp;</a></span>FlushPrintBufferIntoFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::FlushPrintBufferIntoFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function prints the message dumped by kernel into file instead of stdout. </p>
<p >This function's usage is the same as <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html#a119687d90a19d1f7e9b18dfa5ae0cdc3" title="This function prints the message on the standard display device that are dumped by kernel.">CmDevice::FlushPrintBuffer()</a>. It is recommended to use this interface when there are tons of messages from kernel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>name of file the message printed into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the buffer is flushed successfully into file. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac52bd18f6de5184dbe014e2bb62575a4" name="ac52bd18f6de5184dbe014e2bb62575a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52bd18f6de5184dbe014e2bb62575a4">&#9670;&nbsp;</a></span>ForceDestroyBufferUP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::ForceDestroyBufferUP </td>
          <td>(</td>
          <td class="paramtype">CmBufferUP *&amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forces the BufferUP object to be destroyed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>Reference to the pointer pointing to CmBufferUP. It will be assigned to nullptr once the function is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if CmBufferUP is successfully destroyed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5459c7ca2ff0a37951764c054838a45" name="ab5459c7ca2ff0a37951764c054838a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5459c7ca2ff0a37951764c054838a45">&#9670;&nbsp;</a></span>GetCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::GetCaps </td>
          <td>(</td>
          <td class="paramtype">CM_DEVICE_CAP_NAME&#160;</td>
          <td class="paramname"><em>capName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>capValueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>capValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can be used to get HW capability. </p>
<p >Since Emulation mode is run during kernel development the values returned in Emulation mode reflect the capabilities at that time, and might not reflect the latest HW capabilities using a later driver release </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capName</td><td>Name of cap to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">capValueSize</td><td>Reference to the size in bytes of the Cap value. On entry application should set this to the size of memory allocated for the cap value. Application should make sure this size is large enough to hold the Cap value requested. On return from this function the actual size of cap value is returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">capValue</td><td>Pointer pointing to memory where the cap value should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the input capValueSize equals or is larger than required Cap size and Cap Value is successfully returned, </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise</td></tr>
  </table>
  </dd>
</dl>
<table class="doxtable">
<tr>
<th>Cap Name </th><th>Size in bytes  </th><th>Type of Value </th><th>Description  </th></tr>
<tr>
<td>CAP_KERNEL_COUNT_PER_TASK </td><td>4 </td><td>uint32_t </td><td>Maximum number of kernels that can be enqueued in one task  </td></tr>
<tr>
<td>CAP_KERNEL_BINARY_SIZE </td><td>4 </td><td>uint32_t </td><td>Maximum kernel binary size in bytes  </td></tr>
<tr>
<td>CAP_SAMPLER_COUNT </td><td>4 </td><td>uint32_t </td><td>Maximum number of samplers that can co-exist at any time in a <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a>  </td></tr>
<tr>
<td>CAP_SAMPLER_COUNT_PER_KERNEL  </td><td>4 </td><td>uint32_t </td><td>Maximum number of samplers that one kernel can use  </td></tr>
<tr>
<td>CAP_BUFFER_COUNT  </td><td>4 </td><td>uint32_t </td><td>Maximum number of CmBuffer that can co - exist at any time   </td></tr>
<tr>
<td>CAP_SURFACE2D_COUNT </td><td>4 </td><td>uint32_t </td><td>Maximum number of <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> that can co-exist at any time   </td></tr>
<tr>
<td>CAP_SURFACE3D_COUNT  </td><td>4 </td><td>uint32_t </td><td>Maximum number of CmSurface3D that can co-exist at any time in a <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a>   </td></tr>
<tr>
<td>CAP_SURFACE_COUNT_PER_KERNEL  </td><td>4 </td><td>uint32_t </td><td>Maximum number of surfaces (including 1D, 2D and 3D) that one kernel can use   </td></tr>
<tr>
<td>CAP_ARG_COUNT_PER_KERNEL  </td><td>4 </td><td>uint32_t </td><td>Maximum number of arguments that a kernel can have   </td></tr>
<tr>
<td>CAP_ARG_SIZE_PER_KERNEL  </td><td>4 </td><td>uint32_t </td><td>Maximum size of all arguments that a kernel can have   </td></tr>
<tr>
<td>CAP_USER_DEFINED_THREAD_COUNT_PER_TASK  </td><td>4 </td><td>uint32_t </td><td>Maximum number of threads that all kernels of a task can run, it's only used for media object usage   </td></tr>
<tr>
<td>CAP_HW_THREAD_COUNT  </td><td>4 </td><td>uint32_t </td><td>Maximum number of threads that HW can run in parallel.This indicates hardware parallelism and is hence one of the factors indicating performance of the target machine  </td></tr>
<tr>
<td>CAP_SURFACE2D_FORMAT_COUNT  </td><td>4 </td><td>uint32_t </td><td>Number of DDI formats supported for <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> creation  </td></tr>
<tr>
<td>CAP_SURFACE2D_FORMATS  </td><td>sizeof(DDIFORMAT) * CAP_SURFACE2D_FORMAT_COUNT </td><td>Array of DDIFORMAT </td><td>All DDI format supported to create <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>  </td></tr>
<tr>
<td>CAP_SURFACE3D_FORMAT_COUNT  </td><td>sizeof(DDIFORMAT) * CAP_SURFACE3D_FORMAT_COUNT </td><td>Array of DDIFORMAT </td><td>Number of DDI formats supported for CmSurface3D creation  </td></tr>
<tr>
<td>CAP_SURFACE3D_FORMATS  </td><td>sizeof(DDIFORMAT) * CAP_SURFACE3D_FORMAT_COUNT </td><td>Array of DDIFORMAT </td><td>All DDI format supported to create CmSurface3D  </td></tr>
<tr>
<td>CAP_VME_STATE_COUNT  </td><td>4 </td><td>uint32_t </td><td>Maximum number of VME states that can co - exist at any time in a <a class="el" href="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device.html" title="CmDevice class @UMD for Linux.">CmDevice</a>  </td></tr>
<tr>
<td>CAP_GPU_PLATFORM  </td><td>4 </td><td>uint32_t </td><td>Return GPU platform as an enum of type GPU_PLATFORM (PLATFORM_INTEL_SNB, PLATFORM_INTEL_IVB, etc)  </td></tr>
<tr>
<td>CAP_GT_PLATFORM  </td><td>4 </td><td>uint32_t </td><td>Return GT platform (SKU) as an enum of type GPU_GT_PLATFORM (PLATFORM_INTEL_GT1, PLATFORM_INTEL_GT2, etc)  </td></tr>
<tr>
<td>CAP_MIN_FREQUENCY  </td><td>4 </td><td>uint32_t </td><td>Returns the minimum frequency of the GPU as an integer in MHz  </td></tr>
<tr>
<td>CAP_MAX_FREQUENCY  </td><td>4 </td><td>uint32_t </td><td>Returns the maximum frequency of the GPU as an integer in MHz  </td></tr>
<tr>
<td>CAP_GPU_CURRENT_FREQUENCY  </td><td>4 </td><td>uint32_t </td><td>Return the current frequency of the GPU as an integer in MHz   </td></tr>
<tr>
<td>CAP_USER_DEFINED_THREAD_COUNT_PER_TASK_NO_THREAD_ARG  </td><td>4 </td><td>uint32_t </td><td>Returns the maximum thread count on media object without per - thread argument   </td></tr>
<tr>
<td>CAP_USER_DEFINED_THREAD_COUNT_PER_MEDIA_WALKER  </td><td>4 </td><td>uint32_t </td><td>Returns the maximum thread count in media walker usage   </td></tr>
<tr>
<td>CAP_USER_DEFINED_THREAD_COUNT_PER_THREAD_GROUP  </td><td>4 </td><td>uint32_t </td><td>Returns the maximum thread count per thread group in GPGPU walker usage   </td></tr>
<tr>
<td>CAP_SURFACE2DUP_COUNT  </td><td>4 </td><td>uint32_t </td><td>Maximum number of CmSurface2DUP that can co - exist at any time   </td></tr>
</table>

</div>
</div>
<a id="a8cbcddd96adb0e8f9f553b506a58ed2b" name="a8cbcddd96adb0e8f9f553b506a58ed2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbcddd96adb0e8f9f553b506a58ed2b">&#9670;&nbsp;</a></span>GetSurface2DInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::GetSurface2DInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_SURFACE_FORMAT&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>physicalSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets Surface2D allocation information by given width, height, and format. </p>
<p >Gets necessary information in order to create and use CmSurface2DUP. To create CmSurface2DUP, user needs to allocated such amount of system memory which equals to or larger than physical size returned here. When accessing the system memory, the user needs be aware about pitch, which is equal to (pixel_width * byte_per_pixel + necessary_padding). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width in pixel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>height in pixel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>pixel format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pitch</td><td>Reference to returned pitch. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">physicalSize</td><td>Reference to returned physical size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38b622b07cc3ee52c868d5c46793013d" name="a38b622b07cc3ee52c868d5c46793013d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b622b07cc3ee52c868d5c46793013d">&#9670;&nbsp;</a></span>GetVISAVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::GetVISAVersion </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>majorVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>minorVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the VISA version up-to which IGC supports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">majorVersion</td><td>The major Version of VISA. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minorVersion</td><td>The minor Version of VISA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if get the right VISA version. </td></tr>
    <tr><td class="paramname">CM_JITDLL_LOAD_FAILURE</td><td>if loading igc library is failed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API is implemented in hardware mode only. </dd></dl>

</div>
</div>
<a id="afc52c3f35d597e83ae5345f094650e1c" name="afc52c3f35d597e83ae5345f094650e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc52c3f35d597e83ae5345f094650e1c">&#9670;&nbsp;</a></span>InitPrintBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::InitPrintBuffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em> = <code>CM_DEFAULT_PRINT_BUFFER_SIZE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function creates a buffer to store the message printed by printf() in kernel side. </p>
<p >The default size of print buffer is 1M bytes. User can set its size according to the length of message printed in kernel and the number of threads. printf() can be used for kernel debug purpose </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of print buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the print buffer is created successfully. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if print buffer allication is failed. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Internally the print buffer occupies static buffer index 1, thus only other 3 static buffers can be used by host (0, 2, 3) if print functionality is enabled. </dd></dl>

</div>
</div>
<a id="ad56005b2f4fa8a79b067cedabbc545e0" name="ad56005b2f4fa8a79b067cedabbc545e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56005b2f4fa8a79b067cedabbc545e0">&#9670;&nbsp;</a></span>LoadProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::LoadProgram </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>commonIsaCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmProgram *&amp;&#160;</td>
          <td class="paramname"><em>program</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>options</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a CmProgram object consisting of kernels loaded from the commonIsaCode code. </p>
<p >Common ISA code is offline generated as a file with a .isa suffix by the CM compiler when it is used to compile one or more kernels. It contains ISA code common for all Intel platforms. Just-In-Time (JIT) compilation of the common ISA code happens in LoadProgram and generates platform specific ISA according to the actaully platform where the application in running in hardware mode. In the emulation mode JIT doesn't happen. In the simulation mode JIT doesn't happen but paltform specfic ISA need to be offline generated together with common ISA by CM compiler and to be included in commonIsaCode. How to generate common ISA and platform specific ISA can be found in CM compiler manual. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commonIsaCode</td><td>Pointer pointing to code in common ISA. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size in bytes of the common ISA code. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">program</td><td>Reference to the pointer to the CmProgram. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>JIT options for all kernels in the code. This argument is optional. Size of options should be no more than 512 (CM_MAX_OPTION_SIZE_IN_BYTE) bytes including the null terminator. There is one option available currently: <br  />
 "nojitter" &ndash; Use this option to completely disable jitter from occurring. NOTE: "/Qxcm_jit_tartget=%GEN_ARCH%" flag must be set during offline compilation if "nojitter" is set in hardware mode. In simulation and emulation mode, this option is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmProgram is successfully created. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if invalid input parameters. </td></tr>
    <tr><td class="paramname">CM_INVALID_GENX_BINARY</td><td>if the GEN binary is not matched with actual running platform in "nojitter" mode. </td></tr>
    <tr><td class="paramname">CM_JIT_COMPILE_FAILURE</td><td>if JIT compile of the common ISA code fails. </td></tr>
    <tr><td class="paramname">CM_INVALID_KERNEL_SPILL_CODE</td><td>if kernel has spill code and devcie's scratch memory space is disabled in CreateCmDeviceEx. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d5a716edbf90cb2faf4a59635aa7160" name="a2d5a716edbf90cb2faf4a59635aa7160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5a716edbf90cb2faf4a59635aa7160">&#9670;&nbsp;</a></span>SetCaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::SetCaps </td>
          <td>(</td>
          <td class="paramtype">CM_DEVICE_CAP_NAME&#160;</td>
          <td class="paramname"><em>capName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capValueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>capValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can be used to set/limit hardware capabilities- number of threads that HW can run in parallel. </p>
<p >Hardware thread number can be set from 1 to maximum. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">capName</td><td>Name of cap to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capValueSize</td><td>The size of the cap value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capValue</td><td>Pointer to the cap value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if cap value is valid and is set correctly. </td></tr>
    <tr><td class="paramname">CM_INVALID_HARDWARE_THREAD_NUMBER</td><td>specific SetCaps error message if cap value is not valid. </td></tr>
    <tr><td class="paramname">CM_NOT_IMPLEMENTED</td><td>for emulation mode. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The following is the specific behavior for the cap value that is being set. <table class="doxtable">
<tr>
<th>Cap name&lt; / th&gt; </th><th>Behavior&lt; / th&gt; &lt; / tr&gt; </th></tr>
<tr>
<td>CAP_HW_THREAD_COUNT&lt; / td&gt; </td><td>The number of hardware threads is per - task.A call to the SetCaps function to set the CAP_HW_THREAD_COUNT will limit the maximum number of hardware threads for the ensuing call to Enqueue.After the call to Enqueue, the maximum number of hardware threads will be restored to its default value, which is determined by the hardware's capability. &lt; / td&gt; &lt; / tr&gt; &lt; / table&gt; </td></tr>
</table>
</dd></dl>

</div>
</div>
<a id="a5d036e7ea22baed89307ed1e5f16c744" name="a5d036e7ea22baed89307ed1e5f16c744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d036e7ea22baed89307ed1e5f16c744">&#9670;&nbsp;</a></span>SetL3Config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::SetL3Config </td>
          <td>(</td>
          <td class="paramtype">const L3ConfigRegisterValues *&#160;</td>
          <td class="paramname"><em>l3Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the configuration for L3 cache. </p>
<p >This API allows users to configure L3 cach by themselves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l3Config</td><td>L3ConfigRegisterValues contains the values of L3 control registers. The registers are different from platform to platform. <br  />
 struct L3ConfigRegisterValues <br  />
 { <br  />
 \t unsigned int config_register0; <br  />
 \t unsigned int config_register1; <br  />
 \t unsigned int config_register2; <br  />
 \t unsigned int config_register3; <br  />
 }; <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the L3 configuration pointer is set correctly. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>if the platform does not support L3 or L3 configuration failed to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is implemented for both hardware mode and simulation mode. </dd></dl>

</div>
</div>
<a id="a4c9ef126243d4246a0a59e8879e13404" name="a4c9ef126243d4246a0a59e8879e13404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9ef126243d4246a0a59e8879e13404">&#9670;&nbsp;</a></span>SetSuggestedL3Config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::SetSuggestedL3Config </td>
          <td>(</td>
          <td class="paramtype">L3_SUGGEST_CONFIG&#160;</td>
          <td class="paramname"><em>l3SuggestConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the suggested configuration for L3 cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l3SuggestConfig</td><td>The configuration plan which represents a suggested L3 configuration. These configurations are defined in ::L3_SUGGEST_CONFIG which is a enumeration definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the L3 configuration pointer is set correctly. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>if the platform does not support L3 or L3 configuration failed to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only implemented for hardware and simulation modes. </dd></dl>

</div>
</div>
<a id="a982a91f8c9b2d4c8591308b8929e563d" name="a982a91f8c9b2d4c8591308b8929e563d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982a91f8c9b2d4c8591308b8929e563d">&#9670;&nbsp;</a></span>SetVmeSurfaceStateParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::SetVmeSurfaceStateParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&#160;</td>
          <td class="paramname"><em>vmeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CM_VME_SURFACE_STATE_PARAM *&#160;</td>
          <td class="paramname"><em>surfStateParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the width and height values in the VME surface state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vmeIndex</td><td>Pointer to VME surface index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfStateParam</td><td>Pointer to CM_VME_SURFACE_STATE_PARAM to set width and height of this surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if setting VME surface state values successfully. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if invalid input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API will work on HW and SIM modes. </dd></dl>

</div>
</div>
<a id="af54f021faa2fc49d62ba553e744f273b" name="af54f021faa2fc49d62ba553e744f273b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54f021faa2fc49d62ba553e744f273b">&#9670;&nbsp;</a></span>UpdateBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::UpdateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a>&#160;</td>
          <td class="paramname"><em>mosResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmBuffer *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MOS_HW_RESOURCE_DEF&#160;</td>
          <td class="paramname"><em>mosUsage</em> = <code>MOS_CM_RESOURCE_USAGE_SurfaceState</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the MOS Resource in the CmBuffer. If surface is null, creates a new CmBuffer. </p>
<p >CmBuffer is a wrapper of that MOS resource. This Mos resource is owned by caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mosResource</td><td>pointer to MOS resource. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>reference to pointer of surface to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mosUsage</td><td>The selected pre-defined MOS usage of memory object control cache setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the CmBuffer is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_MOS_RESOURCE_HANDLE</td><td>if mosResource is nullptr. </td></tr>
    <tr><td class="paramname">CM_OUT_OF_HOST_MEMORY</td><td>if out of system memory </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 1D surfaces is exceeded. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fe95387d193d0232c0f25646288428" name="aa3fe95387d193d0232c0f25646288428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fe95387d193d0232c0f25646288428">&#9670;&nbsp;</a></span>UpdateSurface2D()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmDevice::UpdateSurface2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a>&#160;</td>
          <td class="paramname"><em>mosResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> *&amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MOS_HW_RESOURCE_DEF&#160;</td>
          <td class="paramname"><em>mosUsage</em> = <code>MOS_CM_RESOURCE_USAGE_SurfaceState</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the MOS Resource in the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. If surface is null, creates a new <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p ><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is a wrapper of that MOS resource. This Mos resource is owned by caller. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mosResource</td><td>pointer to MOS resource. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">surface</td><td>reference to pointer of surface to be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mosUsage</td><td>The selected pre-defined MOS usage of memory object control cache setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is successfully created. </td></tr>
    <tr><td class="paramname">CM_INVALID_MOS_RESOURCE_HANDLE</td><td>if pMosResrouce is nullptr. </td></tr>
    <tr><td class="paramname">CM_EXCEED_SURFACE_AMOUNT</td><td>if maximum amount of 2D surfaces is exceeded. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="../../d2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_aa3fe95387d193d0232c0f25646288428_icgraph.png" border="0" usemap="#ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_aa3fe95387d193d0232c0f25646288428_icgraph" alt=""/></div>
<map name="ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_aa3fe95387d193d0232c0f25646288428_icgraph" id="ad2/d38/class_c_m_r_t___u_m_d_1_1_cm_device_aa3fe95387d193d0232c0f25646288428_icgraph">
<area shape="rect" title="Update the MOS Resource in the CmSurface2D. If surface is null, creates a new CmSurface2D." alt="" coords="196,5,356,47"/>
<area shape="rect" href="../../d0/df9/cm__surface__2d__wrapper_8cpp.html#a1f388b85f7b9853ae16336af9146959e" title=" " alt="" coords="5,13,148,39"/>
</map>
</div>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/xiaoganx/Project/media-driver/media_driver/linux/common/cm/hal/<a class="el" href="../../d8/d64/cm__device_8h_source.html">cm_device.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
