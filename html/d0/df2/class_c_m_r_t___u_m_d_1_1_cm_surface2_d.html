<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Intel Media Driver Document: CMRT_UMD::CmSurface2D Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Intel Media Driver Document<span id="projectnumber">&#160;23.2.4</span>
   </div>
   <div id="projectbrief">This document is for intel media driver which locate at https://github.com/intel/media-driver.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d8/df2/namespace_c_m_r_t___u_m_d.html">CMRT_UMD</a></li><li class="navelem"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../da/d0b/class_c_m_r_t___u_m_d_1_1_cm_surface2_d-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CMRT_UMD::CmSurface2D Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../d9/d0a/cm__surface__2d_8h_source.html">cm_surface_2d.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aec42b185674e98c2e745e3ad1ddc5987"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#aec42b185674e98c2e745e3ad1ddc5987">GetIndex</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;index)=0</td></tr>
<tr class="memdesc:aec42b185674e98c2e745e3ad1ddc5987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves surface index of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#aec42b185674e98c2e745e3ad1ddc5987">More...</a><br /></td></tr>
<tr class="separator:aec42b185674e98c2e745e3ad1ddc5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca537466bab742d4198371c250e68202"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#aca537466bab742d4198371c250e68202">ReadSurface</a> (unsigned char *sysMem, CmEvent *event, uint64_t sysMemSize=0xFFFFFFFFFFFFFFFFULL)=0</td></tr>
<tr class="memdesc:aca537466bab742d4198371c250e68202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data in this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> to system memory.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#aca537466bab742d4198371c250e68202">More...</a><br /></td></tr>
<tr class="separator:aca537466bab742d4198371c250e68202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627ecc2eba8d3145eb5c354fe4287acc"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a627ecc2eba8d3145eb5c354fe4287acc">WriteSurface</a> (const unsigned char *sysMem, CmEvent *event, uint64_t sysMemSize=0xFFFFFFFFFFFFFFFFULL)=0</td></tr>
<tr class="memdesc:a627ecc2eba8d3145eb5c354fe4287acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data in system memory to this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a627ecc2eba8d3145eb5c354fe4287acc">More...</a><br /></td></tr>
<tr class="separator:a627ecc2eba8d3145eb5c354fe4287acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7ec309d0db9b47ce3cc83387696242"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ace7ec309d0db9b47ce3cc83387696242">ReadSurfaceStride</a> (unsigned char *sysMem, CmEvent *event, const unsigned int stride, uint64_t sysMemSize=0xFFFFFFFFFFFFFFFFULL)=0</td></tr>
<tr class="memdesc:ace7ec309d0db9b47ce3cc83387696242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data in this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> to system memory with system memory stride.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ace7ec309d0db9b47ce3cc83387696242">More...</a><br /></td></tr>
<tr class="separator:ace7ec309d0db9b47ce3cc83387696242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7674e5b1ff7fc2b7b56c099bde9eeab"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ac7674e5b1ff7fc2b7b56c099bde9eeab">WriteSurfaceStride</a> (const unsigned char *sysMem, CmEvent *event, const unsigned int stride, uint64_t sysMemSize=0xFFFFFFFFFFFFFFFFULL)=0</td></tr>
<tr class="memdesc:ac7674e5b1ff7fc2b7b56c099bde9eeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data in system memory to this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> with system memory stride.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ac7674e5b1ff7fc2b7b56c099bde9eeab">More...</a><br /></td></tr>
<tr class="separator:ac7674e5b1ff7fc2b7b56c099bde9eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9e1de1cf0f7e7c2ce64c16bc348086"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a8d9e1de1cf0f7e7c2ce64c16bc348086">InitSurface</a> (const unsigned int initValue, CmEvent *event, unsigned int useGPU=0)=0</td></tr>
<tr class="memdesc:a8d9e1de1cf0f7e7c2ce64c16bc348086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets surface data to a unified value.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a8d9e1de1cf0f7e7c2ce64c16bc348086">More...</a><br /></td></tr>
<tr class="separator:a8d9e1de1cf0f7e7c2ce64c16bc348086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9f7295e23a2cae2e2e581a1ed80b7b"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#aaf9f7295e23a2cae2e2e581a1ed80b7b">GetVaSurfaceID</a> (VASurfaceID &amp;vaSurface)=0</td></tr>
<tr class="memdesc:aaf9f7295e23a2cae2e2e581a1ed80b7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves libva surface ID.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#aaf9f7295e23a2cae2e2e581a1ed80b7b">More...</a><br /></td></tr>
<tr class="separator:aaf9f7295e23a2cae2e2e581a1ed80b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ef9fd1d7714c4926e849cdd71ff440"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a14ef9fd1d7714c4926e849cdd71ff440">ReadSurfaceHybridStrides</a> (unsigned char *sysMem, CmEvent *event, const unsigned int horizontalStride, const unsigned int verticalStride, uint64_t sysMemSize=0xFFFFFFFFFFFFFFFFULL, unsigned int option=0)=0</td></tr>
<tr class="memdesc:a14ef9fd1d7714c4926e849cdd71ff440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid memory copy from this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> to system memory with system memory strides.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a14ef9fd1d7714c4926e849cdd71ff440">More...</a><br /></td></tr>
<tr class="separator:a14ef9fd1d7714c4926e849cdd71ff440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b8a1d8507ad1ab76f9f18ee321f345"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a70b8a1d8507ad1ab76f9f18ee321f345">WriteSurfaceHybridStrides</a> (const unsigned char *sysMem, CmEvent *event, const unsigned int horizontalStride, const unsigned int verticalStride, uint64_t sysMemSize=0xFFFFFFFFFFFFFFFFULL, unsigned int option=0)=0</td></tr>
<tr class="memdesc:a70b8a1d8507ad1ab76f9f18ee321f345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid memory copy from system memory to this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> with system memory stride.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a70b8a1d8507ad1ab76f9f18ee321f345">More...</a><br /></td></tr>
<tr class="separator:a70b8a1d8507ad1ab76f9f18ee321f345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b3749bad97db5b86491b0b3a07bca"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ab70b3749bad97db5b86491b0b3a07bca">SelectMemoryObjectControlSetting</a> (MEMORY_OBJECT_CONTROL memCtrl)=0</td></tr>
<tr class="memdesc:ab70b3749bad97db5b86491b0b3a07bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects one of the pre-defined memory object control settings for this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ab70b3749bad97db5b86491b0b3a07bca">More...</a><br /></td></tr>
<tr class="separator:ab70b3749bad97db5b86491b0b3a07bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab052c8f3cd44afb3bd51782be1487258"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ab052c8f3cd44afb3bd51782be1487258">SetProperty</a> (CM_FRAME_TYPE frameType)=0</td></tr>
<tr class="memdesc:ab052c8f3cd44afb3bd51782be1487258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets frame type of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ab052c8f3cd44afb3bd51782be1487258">More...</a><br /></td></tr>
<tr class="separator:ab052c8f3cd44afb3bd51782be1487258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad102b650c163a3960c345ede98916cf7"><td class="memItemLeft" align="right" valign="top">virtual CM_RT_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ad102b650c163a3960c345ede98916cf7">SetSurfaceStateParam</a> (<a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *surfIndex, const CM_SURFACE2D_STATE_PARAM *surfStateParam)=0</td></tr>
<tr class="memdesc:ad102b650c163a3960c345ede98916cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets surface state parameters for an alias of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ad102b650c163a3960c345ede98916cf7">More...</a><br /></td></tr>
<tr class="separator:ad102b650c163a3960c345ede98916cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababb338c4c5d84e8ad027221e8532d33"><td class="memItemLeft" align="right" valign="top">virtual CMRT_UMD_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ababb338c4c5d84e8ad027221e8532d33">SetResourceUsage</a> (MOS_HW_RESOURCE_DEF mosUsage)=0</td></tr>
<tr class="memdesc:ababb338c4c5d84e8ad027221e8532d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects one of the pre-defined MOS resource usage settings for this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ababb338c4c5d84e8ad027221e8532d33">More...</a><br /></td></tr>
<tr class="separator:ababb338c4c5d84e8ad027221e8532d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a11f10fadbdd088a32af04241123d5"><td class="memItemLeft" align="right" valign="top">virtual CMRT_UMD_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ae4a11f10fadbdd088a32af04241123d5">SetReadSyncFlag</a> (bool readSync, CmQueue *pCmQueue)=0</td></tr>
<tr class="memdesc:ae4a11f10fadbdd088a32af04241123d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the surface's read sync flag for synchronization between engines.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#ae4a11f10fadbdd088a32af04241123d5">More...</a><br /></td></tr>
<tr class="separator:ae4a11f10fadbdd088a32af04241123d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011254f11748b821ec5f78a7bd4eb28c"><td class="memItemLeft" align="right" valign="top">virtual CMRT_UMD_API int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a011254f11748b821ec5f78a7bd4eb28c">NotifyUmdResourceChanged</a> (<a class="el" href="../../de/d8b/cm__innerdef__os_8h.html#a1897ec11c6056b7ddd169cf0e9842dbd">UMD_RESOURCE</a> umdResource, int updateMosResource=0, <a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a> mosResource=nullptr)=0</td></tr>
<tr class="memdesc:a011254f11748b821ec5f78a7bd4eb28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the UMD Resource and MOS Resource in the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>.  <a href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html#a011254f11748b821ec5f78a7bd4eb28c">More...</a><br /></td></tr>
<tr class="separator:a011254f11748b821ec5f78a7bd4eb28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="../../d9/d0a/cm__surface__2d_8h_source.html#l00036">36</a> of file <a class="el" href="../../d9/d0a/cm__surface__2d_8h_source.html">cm_surface_2d.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aec42b185674e98c2e745e3ad1ddc5987" name="aec42b185674e98c2e745e3ad1ddc5987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec42b185674e98c2e745e3ad1ddc5987">&#9670;&nbsp;</a></span>GetIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::GetIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&amp;&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves surface index of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>Reference to the pointer to an <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a>. It will point to the internal <a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUECCESS.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf9f7295e23a2cae2e2e581a1ed80b7b" name="aaf9f7295e23a2cae2e2e581a1ed80b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9f7295e23a2cae2e2e581a1ed80b7b">&#9670;&nbsp;</a></span>GetVaSurfaceID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::GetVaSurfaceID </td>
          <td>(</td>
          <td class="paramtype">VASurfaceID &amp;&#160;</td>
          <td class="paramname"><em>vaSurface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves libva surface ID. </p>
<dl class="section note"><dt>Note</dt><dd>This function is a Linux-only API. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vaSurface</td><td>Reference to a VASurfaceID receiving libva surface ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d9e1de1cf0f7e7c2ce64c16bc348086" name="a8d9e1de1cf0f7e7c2ce64c16bc348086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9e1de1cf0f7e7c2ce64c16bc348086">&#9670;&nbsp;</a></span>InitSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::InitSurface </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>initValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>useGPU</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets surface data to a unified value. </p>
<p >This is a blocking function, i.e. the function will not return until the operation is completed. Initialization will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>The value for initialization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if initialization is successful. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a011254f11748b821ec5f78a7bd4eb28c" name="a011254f11748b821ec5f78a7bd4eb28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011254f11748b821ec5f78a7bd4eb28c">&#9670;&nbsp;</a></span>NotifyUmdResourceChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CMRT_UMD_API int32_t CMRT_UMD::CmSurface2D::NotifyUmdResourceChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d8b/cm__innerdef__os_8h.html#a1897ec11c6056b7ddd169cf0e9842dbd">UMD_RESOURCE</a>&#160;</td>
          <td class="paramname"><em>umdResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>updateMosResource</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d3/da0/mos__os__specific_8h.html#af802a0a20ec057e9c3654db298a7f4af">PMOS_RESOURCE</a>&#160;</td>
          <td class="paramname"><em>mosResource</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the UMD Resource and MOS Resource in the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p >A callback function which allows CM callers to change the UMD Resource and MOS Resource embedded in the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">umdResource</td><td>the UMD Resource set to the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updateMosResource</td><td>a flag indicating whether MOS resource needs updating. 0 mean keeping it unchanged. Otherwise, set the MOS resource to parameter mosResource. Default is 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mosResource</td><td>the MOS Resource set to the <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>always. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca537466bab742d4198371c250e68202" name="aca537466bab742d4198371c250e68202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca537466bab742d4198371c250e68202">&#9670;&nbsp;</a></span>ReadSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::ReadSurface </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sysMemSize</em> = <code>0xFFFFFFFFFFFFFFFFULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data in this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> to system memory. </p>
<p >Copied data size is the same as surface data size. This is a blocking function, i.e. the function will not return until the copy operation is completed. Copying will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. It's the application's responsibility to make sure no other task enqueued between the task corresponding to the event and this fuction call. If sysMemSize is given, it will be checked against the size of the surface data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sysMem</td><td>Pointer to the system memory receiving surface data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMemSize</td><td>Size of the system memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if this function succeeds. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMemSize is given but less than what is needed. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14ef9fd1d7714c4926e849cdd71ff440" name="a14ef9fd1d7714c4926e849cdd71ff440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ef9fd1d7714c4926e849cdd71ff440">&#9670;&nbsp;</a></span>ReadSurfaceHybridStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::ReadSurfaceHybridStrides </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>horizontalStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>verticalStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sysMemSize</em> = <code>0xFFFFFFFFFFFFFFFFULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>option</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hybrid memory copy from this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> to system memory with system memory strides. </p>
<p >Copied data size is the same as surface data size. This is a blocking function, i.e. the function will not return until the copy operation is completed. Copying will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. If sysMemSize is given, it will be checked against the size of the surface data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sysMem</td><td>Pointer to the system memory receiving surface data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">horizontalStride</td><td>Horizontal stride of system memory in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verticalStride</td><td>Vertical stride of system memory in rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMemSize</td><td>Size of the system memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option to disable/enable hybrid memory copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if this function succeeds. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMemSize is given but less than what is needed. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace7ec309d0db9b47ce3cc83387696242" name="ace7ec309d0db9b47ce3cc83387696242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7ec309d0db9b47ce3cc83387696242">&#9670;&nbsp;</a></span>ReadSurfaceStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::ReadSurfaceStride </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sysMemSize</em> = <code>0xFFFFFFFFFFFFFFFFULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data in this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> to system memory with system memory stride. </p>
<p >Copied data size is the same as surface data size. This is a blocking function, i.e. the function will not return until the copy operation is completed. Copying will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. It's the application's responsibility to make sure no other task enqueued between the task corresponding to the event and this fuction call. If sysMemSize is given, it will be checked against the size of the surface data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sysMem</td><td>Pointer to the system memory receiving surface data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>System memory stride in bytes. It equals actual surface width in bytes plus extra padding bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMemSize</td><td>Size of the system memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if this function succeeds. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMemSize is given but less than what is needed. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab70b3749bad97db5b86491b0b3a07bca" name="ab70b3749bad97db5b86491b0b3a07bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70b3749bad97db5b86491b0b3a07bca">&#9670;&nbsp;</a></span>SelectMemoryObjectControlSetting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::SelectMemoryObjectControlSetting </td>
          <td>(</td>
          <td class="paramtype">MEMORY_OBJECT_CONTROL&#160;</td>
          <td class="paramname"><em>memCtrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects one of the pre-defined memory object control settings for this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function only works on Gen9+ paltforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">memCtrl</td><td>The selected pre-defined memory object control setting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the given parameter is valid </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab052c8f3cd44afb3bd51782be1487258" name="ab052c8f3cd44afb3bd51782be1487258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab052c8f3cd44afb3bd51782be1487258">&#9670;&nbsp;</a></span>SetProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::SetProperty </td>
          <td>(</td>
          <td class="paramtype">CM_FRAME_TYPE&#160;</td>
          <td class="paramname"><em>frameType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets frame type of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p >By default this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is a whole frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">frameType</td><td>A value in enumeration CM_FRAME_TYPE, frame type of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. It should be a whole frame or a field in an interlaced frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4a11f10fadbdd088a32af04241123d5" name="ae4a11f10fadbdd088a32af04241123d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a11f10fadbdd088a32af04241123d5">&#9670;&nbsp;</a></span>SetReadSyncFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CMRT_UMD_API int32_t CMRT_UMD::CmSurface2D::SetReadSyncFlag </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readSync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmQueue *&#160;</td>
          <td class="paramname"><em>pCmQueue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the surface's read sync flag for synchronization between engines. </p>
<p >If the surface is shared between render engine and another engine, the read sync flag is to tell whether the next engine should wait till the kernel execution ends in render engine. If the read sync flag is set, then it means the render engine only read this surface and the next engine can also access it simultaneously. If the read sync flag is not set (or set to false), then the next engine should assume the render engine is writing to this surface and wait till the kernel execution ends. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">readSync</td><td>value of read sync flag to be set to the surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if any parameter is invalid. </td></tr>
    <tr><td class="paramname">CM_SUCCESS</td><td>if successful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ababb338c4c5d84e8ad027221e8532d33" name="ababb338c4c5d84e8ad027221e8532d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ababb338c4c5d84e8ad027221e8532d33">&#9670;&nbsp;</a></span>SetResourceUsage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CMRT_UMD_API int32_t CMRT_UMD::CmSurface2D::SetResourceUsage </td>
          <td>(</td>
          <td class="paramtype">MOS_HW_RESOURCE_DEF&#160;</td>
          <td class="paramname"><em>mosUsage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Selects one of the pre-defined MOS resource usage settings for this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This function works only on Gen9+ paltforms. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mosUsage</td><td>The selected pre-defined MOS resource usage for memory object control setting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if the given parameter is valid </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad102b650c163a3960c345ede98916cf7" name="ad102b650c163a3960c345ede98916cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad102b650c163a3960c345ede98916cf7">&#9670;&nbsp;</a></span>SetSurfaceStateParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::SetSurfaceStateParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d1e/class_c_m_r_t___u_m_d_1_1_surface_index.html">SurfaceIndex</a> *&#160;</td>
          <td class="paramname"><em>surfIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CM_SURFACE2D_STATE_PARAM *&#160;</td>
          <td class="paramname"><em>surfStateParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets surface state parameters for an alias of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p >If surfIndex is nullptr, default state of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> is changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">surfIndex</td><td>Pointer to the surface index of an alias of this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. A new surface state is created for this alias or the existing state is updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfStateParam</td><td>Pointer to a new state parameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if any parameter is invalid. </td></tr>
    <tr><td class="paramname">CM_SUCCESS</td><td>if successful. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a627ecc2eba8d3145eb5c354fe4287acc" name="a627ecc2eba8d3145eb5c354fe4287acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627ecc2eba8d3145eb5c354fe4287acc">&#9670;&nbsp;</a></span>WriteSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::WriteSurface </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sysMemSize</em> = <code>0xFFFFFFFFFFFFFFFFULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data in system memory to this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a>. </p>
<p >Copied data size is the same as the surface data size. This is a blocking function, i.e. the function will not return until the copy operation is completed. Copying will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. If sysMemSize is given, it will be checked against the size of the surface data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMem</td><td>Pointer to the system memory storing surface data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMemSize</td><td>Size of the system memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if copy is successful. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMemSize is given but less than what is needed. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b8a1d8507ad1ab76f9f18ee321f345" name="a70b8a1d8507ad1ab76f9f18ee321f345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b8a1d8507ad1ab76f9f18ee321f345">&#9670;&nbsp;</a></span>WriteSurfaceHybridStrides()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::WriteSurfaceHybridStrides </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>horizontalStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>verticalStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sysMemSize</em> = <code>0xFFFFFFFFFFFFFFFFULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>option</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hybrid memory copy from system memory to this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> with system memory stride. </p>
<p >Copied data size is the same as the surface data size. This is a blocking function, i.e. the function will not return until the copy operation is completed. Copying will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. If sysMemSize is given, it will be checked against the size of the surface data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMem</td><td>Pointer to the system memory storing surface data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">horizontalStride</td><td>Horizontal stride of system memory in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verticalStride</td><td>Vertical stride of system memory in rows. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMemSize</td><td>Size of the system memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>Option to disable/enable hybrid memory copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if copy is successful. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMemSize is given but less than what is needed. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7674e5b1ff7fc2b7b56c099bde9eeab" name="ac7674e5b1ff7fc2b7b56c099bde9eeab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7674e5b1ff7fc2b7b56c099bde9eeab">&#9670;&nbsp;</a></span>WriteSurfaceStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CM_RT_API int32_t CMRT_UMD::CmSurface2D::WriteSurfaceStride </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>sysMem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CmEvent *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sysMemSize</em> = <code>0xFFFFFFFFFFFFFFFFULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data in system memory to this <a class="el" href="../../d0/df2/class_c_m_r_t___u_m_d_1_1_cm_surface2_d.html">CmSurface2D</a> with system memory stride. </p>
<p >Copied data size is the same as the surface data size. This is a blocking function, i.e. the function will not return until the copy operation is completed. Copying will not happen until the status of the dependent event becomes CM_STATUS_FINISHED. If sysMemSize is given, it will be checked against the size of the surface data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMem</td><td>Pointer to the system memory storing surface data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Pointer to the dependent event used for sychronization. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stride</td><td>System memory stride in bytes. It equals actual surface width in bytes plus extra padding bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysMemSize</td><td>Size of the system memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CM_SUCCESS</td><td>if copy is successful. </td></tr>
    <tr><td class="paramname">CM_INVALID_ARG_VALUE</td><td>if sysMemSize is given but less than what is needed. </td></tr>
    <tr><td class="paramname">CM_LOCK_SURFACE_FAIL</td><td>if surface locking fails. </td></tr>
    <tr><td class="paramname">CM_FAILURE</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/xiaoganx/Project/media_driver_upstream/media-driver/media_driver/linux/common/cm/hal/<a class="el" href="../../d9/d0a/cm__surface__2d_8h_source.html">cm_surface_2d.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
